## 原理
首先要从Vue中的两个API说起，这个Api就是Vue.extend和Vue.component。我们知道在Vue中定义组件有两种方式：

1. 定义全局组件 也就是调用Vue.component传入组件id和组件配置对象options
2. 定义局部组件 也就是在导出的options对象中的components字段对应的对象中，以组件的id当做key，以组件的配置对象options当做value，来声明一个局部组件

但是我们阅读了Vue.component的源码后就会发现，无论是全局组件还是局部组件内部都会调用一个名为Vue.extend的API。这里首先说下Vue.extend的作用。

Vue.extend方法接收一个组件配置对象options当做参数，然后内部做做三件事：
1. 声明一个构造函数Sub，这将会是Vue的子类
2. 将Sub的原型通过Object.create方法指向Vue.prototype，实现类的继承
3. 将方法的参数options和全局Vue.options通过mergeOptions策略模式进行合并，并将合并后的对象挂载到Sub的options属性上
4. 最后将这个Sub构造函数返回


所以说声明一个组件的本质就是创建了一个唯一的Vue的子类Sub，然后通过new Sub(options)就可以得到一个组件实例vm，在new Sub的过程中会再次将Sub.options对象和空对象{}进行合并，并将合并后的对象赋值给vm.$options，也就是挂载到组件实例的$options属性上，之后我们在初始化组件的状态比如data的时候，就会去这个vm.$options上取值。

所以到这里，这个问题的答案就呼之欲之了。

假设我们给组件的options.data传入一个对象，那么之后我们多次new这个组件的Sub构造函数，在初始化之后得到的vm.$options.data都是同一个对象，如果我们在任意一个组件内部通过this.xxx修改了data中的属性，由于引用值的内存地址相同，那么这种修改就会同步给其他实例的data对象。

而如果我们给组件的options.data传入一个函数，由于函数每次创建上下文进行执行之后返回的都是一个全新内存地址的对象，所以就算组件修改了data上的属性也不会导致其他组件实例上的data发生变化，所以Vue组件中的data必须是一个函数。

其实如果我们传递的data是一个对象，那么Vue就会发出一个警告warn，告诉你data options应该是一个函数。 

因为全局的根实例vm只会通过new Vue一次得到，所以根实例的data可以是一个对象；但是组件是通过Vue.extend返回的Sub多次调用创建实例的，所以这个data数据源不能共享，应该都是独立的。