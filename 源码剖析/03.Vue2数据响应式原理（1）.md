## Vue2.0是如何实现响应式数据的？

我将分别从核心实现、源码实现以及存在问题及日常开发中如何避免存在的问题这几个方面去回答问题。

### 1. 核心实现
首先在回答这个问题之前我先说一下什么是响应式数据：我所认为的响应式数据至少应该具备下面两个特点：

+ 数据层面的读取和写入是可以被监听的
+ 监听到数据发生变化之后，可以通知和数据绑定的视图进行更新，视图重新渲染

在Vue2.0中是通过Object.defineProperty API来实现对象属性getter和setter的劫持的，并且在用户一开始初始化data的时候就会去进行属性劫持。按照Vue的设计，每一个模板中使用的数据都有一个dep依赖收集器，每当触发getter的时候收集Wacther，每当触发setter的时候执行notify方法，通知每一个渲染wacther进行渲染。

### 2. 源码实现
在Vue2.0的源码中，当我们在new Vue的时候，会依次调用：
+ 执行Vue构造函数内的_init方法
+ 执行initMixin方法初始化
+ 执行initState方法初始化状态
+ 执行initData方法初始化数据
+ 执行observe方法来new Observer对数据进行响应式劫持
+ 执行walk方法
+ 执行最核心的defineReactive方法，遍历data对象的每一个属性执行该方法
+ 递归劫持和Object.defineProperty

### 3. 存在问题及开发优化建议

1. 递归劫持性能低
由于Vue需要对data对象上的每一个属性都需要递归的属性劫持，那么当对象的嵌套比较多的时候会导致性能消耗很大，所以我们在实际开发中只需要将哪些需要添加到响应式的数据写在data中，对于不添加到响应式系统的数据我们写在外部即可。

2. 避免对属性进行多次连续取值
每一次属性取值都会触发getter，所以如果是下面这种代码，也会导致性能不好 
```js
for(let i=0;i<1000;i++){
    this.total += i;
}
```

这时候我们就可以这样子来优化下：先用一个变量保存，然后最后一起赋值给this.total
```js
let count = 0;
for(let i=0;i<1000;i++){
    count += i;
}
this.total = count;
```

3. 冻结对象
如果我们要把某个对象放在data中，但是这个对象不需要添加到响应式系统中，我们可以采用Object.freeze API去冻结对象，这样就可以避免对这个对象在初始化的时候进行属性劫持。

因为Vue的源码中会判断Object.isExtensible(value)一个值是可拓展的才会去Observer观测，冻结过的对象是不可配置的，所以可以避免对该对象进行属性劫持。



