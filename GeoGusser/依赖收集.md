## 手动更新

现在我们已经知道关于视图渲染有两个核心的方法：
\_render 执行 render 函数返回虚拟 DOM
\_update 将上一步返回的虚拟 DOM 递归生成真实 DOM，渲染到页面上

其实也就是:vm.\_update(vm.\_render());

那么现在如果我们修改了 data 中的属性，比如:

```js
setTimeout(() => {
  vm.age = 20;
  vm.name = "TOM";
}, 1000);
```

视图会随着属性的变化而更新为 20 和 TOM 吗？
很显然是不会的 因为只有调用了 vm.\_update(vm.\_render());这行代码，才会在内部执行 patch 方法，最终完成 appendChild 真实 DOM 挂载和视图渲染。

所以要这样子才会更新：

```js
setTimeout(() => {
  vm.age = 20;
  vm.name = "TOM";
  vm._update(vm._render());
}, 1000);
```

但是我们不可能每次属性改变都去手动调用这行代码，所以我们就需要结合观察者模式，一旦属性发生变化，就通知视图进行自动更新，这才是我们接下来工作的重点。

## 为了避免频繁更新引起的频繁渲染，Vue 的异步更新策略

## Mixin 的实现原理

## 基于观察者模式实现 Vue 中模板的依赖收集

1. 首先你得知道模板中哪些用到了 data 中的属性，可以给模板中的每一个属性增加一个收集器
   这个收集器也叫作依赖收集器，用 dependence 的简写 Dep 表示

2. 页面渲染的时候我们将渲染逻辑封装到 watcher 中 ok

3. 让 Dep 记住这个 watcher，之后当属性变化了，触发了 getter 或 setter 之后就可以找到该属性对应的 Dep 收集器中存放的若干个 watcher，通知他们重新渲染。

### 页面渲染的时候我们将渲染逻辑封装到 watcher 中

只要 new Watcher 就会执行渲染逻辑

```js
// 更新视图
const updateComponent = () => {
  vm._update(vm._render());
};
new Watcher(vm, updateComponent);
```

```js
// Wacther类
let id = 0;
class Watcher {
  /* 
        1. vm：需要告诉我当前这个watcher实例是那个vm实例的
        2. fn：当实例上属性变化的时候要执行的渲染函数逻辑 
    */
  constructor(vm, fn) {
    this.id = id++;
    this.getter = fn;
    this.get();
  }

  get() {
    this.getter();
  }
}
```

### 属性的依赖收集

所谓的依赖收集，就是让模板中的属性收集它所依赖的 watcher，所以我们需要给属性新增一个 dep 属性，这个 dep 属性目的就是收集 watcher

视图就是组件的意思，首先搞明白

1 个视图中可能会有 n 个属性，n 个属性会对应一个视图
因为每一个属性都有一个自己的 dep，所以 n 个属性就会有 n 个 dep
所以：n 个 dep 会对应 1 个视图
又因为 1 个视图对应 1 个 watcher
所以：n 个 dep 对应 1 个 watcher

1个视图中有两个属性name和age，每一个属性都有自己的dep，所以2个dep对应一个视图
也就是2个dep对应一个watcher
```html
<A-CPN>
    <div>{{name}}</div>
    <div>{{age}}</div>
</A-CPN>
```

```js
new Vue({
    data(){
        return {
            name:"lilei",
            age:18
        }
    }
})
```

反过来说：
1 个属性可能对应着多个视图，也就是多个 watcher
比如：一个name属性对应着a组件和b组件两个视图
一个属性有一个dep
所以：1个dep就可能会对应n个watcher


```html
<template>
  <a-cpn :name="name"></a-cpn>
  <b-cpn :name="name"></b-cpn>
</template>
```

```js
new Vue({
    data(){
        return {
            name:"lilei"
        }
    }
})
```

综上所述：dep和watcher是多 对 多的关系
1个dep(属性)可能会对应多个视图watcher
1个watcher(视图)可能会对应多个属性dep

### 属性name和watcher（视图）如何产生关联

1. 给属性name添加一个属性dep
2. 让dep收集watcher
3. name变化触发getter或者setter
4. 通知当前属性name的dep，所对应的多个watcher进行更新
5. watcher依次执行自身的get方法，等于执行getter方法视图就会更新


## 依赖收集 如何给属性绑定dep
1. 给每一个属性都绑定一个唯一的dep

2. 如何将dep和watcher进行关联
+ 首先给Dep添加一个属性target静态属性留好缺口，用于未来的依赖收集目标进行赋值
+ 在Wacther类的getter渲染方法调用之前，给Dep.target赋值为this，也就是watcher

那么关联之后的逻辑就变成了：
1. 当我们创建渲染watcher的时候，我们会将渲染watcher实例放到Dep.target上
2. ...
3. 调用_render的时候去vm上读取属性值，走到属性的getter拦截器函数中
4. 


## 为什么要采用Dep.target = this这种写法关联呢

只有在模板中依赖的属性才需要收集依赖，模板不依赖的不进行收集
```js
get(){
    Dep.target = this;
    // 执行this.getter方法就会读取vm.data上的属性，触发属性的getter，进行依赖收集
    this.getter();
    // 必须清空 否则会导致不被模板依赖的属性发生getter的时候也被收集
    Dep.target = null;
}
```
1. 首先watcher实例上的get方法只有在new Watcher的时候才会触发，什么时候new Watcher呢？答案就是在new Vue完成模板编译和属性劫持之后，执行vm.$mount的时候，就会执行new Watcher，将封装了渲染逻辑的updateComponent方法传入给Watcher类的构造器函数，此时我们是需要依赖收集的

那么就给Dep.target这个类的静态属性赋值为this实例，然后触发属性的getter，该属性的dep就会收集此watcher

2. 如果我们在new Vue的外部，手动的修改了vm.name属性的值，此时依旧会触发属性的getter，但是不会引起依赖的收集，因为此时Dep.target的值为null。所以无法收集，本来我们无法知道name属性是否是被模板依赖的，此时就不用收集，只有在模板编译为render函数之后，被模板依赖的哪些属性才需要收集依赖。

## 执行一次new Watcher之后
name属性会收集到自己的watcher
age顺序
address属性都会收集到，放在自己关联的dep中

## 依赖收集中还是会有的问题

1. 重复进行依赖收集的问题
```html
 <div id="app">
    <span>{{age}} {{name}} {{name}}</span>
  </div>
```
一个name属性触发两次getter，那么会发生重复的收集：
第一次：dep将属性收集到自己的subs中
第二次：再次收集到，也就是说name的dep中收集了两个重复的watcher，其实两个watcher都是一个watcher

如果有10个name呢？那么会触发10次，收集10个watcher，因此需要去重
subs中已经存在了，那就不要再放进来了


2. dep要收集watcher，同时人家watcher也需要收集dep
这里要实现watcher记录dep

3. watcher为什么要记录dep？
比如组件卸载，卸载之后就希望组件的watcher清理掉当前自己模板上关联的所有属性的dep
之后属性发生变化，由于属性的dep中没有此watcher，就和此组件无关了

实现计算属性也需要用到这个

### 双向记录、双向去重（解决依赖重复收集问题）如何实现？

首次name触发getter
dep.depend
Dep.target.addDep(this);
if(!this.depsId.has(depId))判断
this.deps.push(dep);
this.depsId.add(depId);
dep.addSub(this);

第二次name触发getter
dep.depend
Dep.target.addDep(this);
if(!this.depsId.has(depId))判断重复 不执行后续的双向记录 一下子实现了双向去重操作


你想想Vue组件我们常见的两种用法：
1. 一个组件的模板中我们使用了多个属性，这就是一个watcher记录着多个dep
2. 一个属性可能在多个组件中使用，比如一个index组件中有：

header组件
侧边栏组件
底部组件

三个组件都用到了属性userinfo 那么这就是一个dep有多个watcher依赖

总结起来不就是dep和watcher的多对多

### 所有以上工作都是为：
1. 计算属性的实现
2. 以及组件卸载生命周期阶段的清理做准备

### getter收集依赖，setter通知更新