## 手动更新

现在我们已经知道关于视图渲染有两个核心的方法：
\_render 执行 render 函数返回虚拟 DOM
\_update 将上一步返回的虚拟 DOM 递归生成真实 DOM，渲染到页面上

其实也就是:vm.\_update(vm.\_render());

那么现在如果我们修改了 data 中的属性，比如:

```js
setTimeout(() => {
  vm.age = 20;
  vm.name = "TOM";
}, 1000);
```

视图会随着属性的变化而更新为 20 和 TOM 吗？
很显然是不会的 因为只有调用了 vm.\_update(vm.\_render());这行代码，才会在内部执行 patch 方法，最终完成 appendChild 真实 DOM 挂载和视图渲染。

所以要这样子才会更新：

```js
setTimeout(() => {
  vm.age = 20;
  vm.name = "TOM";
  vm._update(vm._render());
}, 1000);
```

但是我们不可能每次属性改变都去手动调用这行代码，所以我们就需要结合观察者模式，一旦属性发生变化，就通知视图进行自动更新，这才是我们接下来工作的重点。

## 为了避免频繁更新引起的频繁渲染，Vue 的异步更新策略

## Mixin 的实现原理

## 基于观察者模式实现 Vue 中模板的依赖收集

1. 首先你得知道模板中哪些用到了 data 中的属性，可以给模板中的每一个属性增加一个收集器
   这个收集器也叫作依赖收集器，用 dependence 的简写 Dep 表示

2. 页面渲染的时候我们将渲染逻辑封装到 watcher 中 ok

3. 让 Dep 记住这个 watcher，之后当属性变化了，触发了 getter 或 setter 之后就可以找到该属性对应的 Dep 收集器中存放的若干个 watcher，通知他们重新渲染。

### 页面渲染的时候我们将渲染逻辑封装到 watcher 中

只要 new Watcher 就会执行渲染逻辑

```js
// 更新视图
const updateComponent = () => {
  vm._update(vm._render());
};
new Watcher(vm, updateComponent);
```

```js
// Wacther类
let id = 0;
class Watcher {
  /* 
        1. vm：需要告诉我当前这个watcher实例是那个vm实例的
        2. fn：当实例上属性变化的时候要执行的渲染函数逻辑 
    */
  constructor(vm, fn) {
    this.id = id++;
    this.getter = fn;
    this.get();
  }

  get() {
    this.getter();
  }
}
```

### 属性的依赖收集

所谓的依赖收集，就是让模板中的属性收集它所依赖的 watcher，所以我们需要给属性新增一个 dep 属性，这个 dep 属性目的就是收集 watcher

视图就是组件的意思，首先搞明白

1 个视图中可能会有 n 个属性，n 个属性会对应一个视图
因为每一个属性都有一个自己的 dep，所以 n 个属性就会有 n 个 dep
所以：n 个 dep 会对应 1 个视图
又因为 1 个视图对应 1 个 watcher
所以：n 个 dep 对应 1 个 watcher

1个视图中有两个属性name和age，每一个属性都有自己的dep，所以2个dep对应一个视图
也就是2个dep对应一个watcher
```html
<A-CPN>
    <div>{{name}}</div>
    <div>{{age}}</div>
</A-CPN>
```

```js
new Vue({
    data(){
        return {
            name:"lilei",
            age:18
        }
    }
})
```

反过来说：
1 个属性可能对应着多个视图，也就是多个 watcher
比如：一个name属性对应着a组件和b组件两个视图
一个属性有一个dep
所以：1个dep就可能会对应n个watcher


```html
<template>
  <a-cpn :name="name"></a-cpn>
  <b-cpn :name="name"></b-cpn>
</template>
```

```js
new Vue({
    data(){
        return {
            name:"lilei"
        }
    }
})
```

综上所述：dep和watcher是多 对 多的关系
1个dep(属性)可能会对应多个视图watcher
1个watcher(视图)可能会对应多个属性dep

### 属性name和watcher（视图）如何产生关联

1. 给属性name添加一个属性dep
2. 让dep收集watcher
3. name变化触发getter或者setter
4. 通知当前属性name的dep，所对应的多个watcher进行更新
5. watcher依次执行自身的get方法，等于执行getter方法视图就会更新


## 依赖收集 如何给属性绑定dep
1. 给每一个属性都绑定一个唯一的dep

2. 如何将dep和watcher进行关联
+ 首先给Dep添加一个属性target静态属性留好缺口，用于未来的依赖收集目标进行赋值
+ 在Wacther类的getter渲染方法调用之前，给Dep.target赋值为this，也就是watcher

那么关联之后的逻辑就变成了：
1. 当我们创建渲染watcher的时候，我们会将渲染watcher实例放到Dep.target上
2. ...
3. 调用_render的时候去vm上读取属性值，走到属性的getter拦截器函数中
4. 
