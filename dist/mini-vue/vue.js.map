{"version":3,"file":"vue.js","sources":["../../src/observer/dep.js","../../src/observer/index.js","../../src/observer/proxy.js","../../src/init/initData.js","../../src/observer/nextTick.js","../../src/observer/watcher.js","../../src/init/initComputed.js","../../src/init/initWatch.js","../../src/init/initState.js","../../src/template-compiler/tagReg.js","../../src/template-compiler/htmlParser.js","../../src/template-compiler/codeGenerator.js","../../src/template-compiler/index.js","../../src/lifeCycle/mountComponent.js","../../src/globalApi/strats.js","../../src/globalApi/mergeOptions.js","../../src/lifeCycle/callHook.js","../../src/init/init.js","../../src/vdom/createNode.js","../../src/vdom/patch.js","../../src/lifeCycle/initLifeCycle.js","../../src/globalApi/index.js","../../src/index.js"],"sourcesContent":["/* \r\n    dep：每一个属性都有的收集器，用来收集该属性对应的所有watcher\r\n    由于1个dep可能对应多个watcher\r\n\r\n    dependence是依赖的意思，也就是依赖收集器\r\n    subscribe是订阅者的意思，代表订阅了当前这个属性变化的watcher\r\n\r\n    dep实例属性：\r\n    + id \r\n    1个watcher也可能对应多个dep，所以dep也得有id表示\r\n\r\n    + subs\r\n    存放着当前属性所对应的所有watcher\r\n\r\n*/\r\nlet id = 0;\r\nclass Dep {\r\n    constructor(){\r\n        this.id = id++;\r\n        this.subs = [];\r\n    }\r\n\r\n    /**\r\n     * 属性getter时：属性的dep对其依赖的watcher进行依赖收集，收集时需要去重\r\n     */\r\n    depend(){\r\n        /* \r\n            这一行代码的作用：\r\n            1. Dep.target是唯一的，它的值是一个读取name属性的watcher\r\n            2. this是当前属性关联的依赖收集器dep的实例\r\n            3. addDep是watcher实例用来记录dep的方法\r\n            4. addSub是dep实例用来进行依赖收集watcher的方法\r\n            5. 会实现双向记录和双向去重的方法\r\n        */\r\n        Dep.target.addDep(this);\r\n\r\n         // 无脑push 不会去重 --- this.subs.push(watcher); \r\n    }\r\n\r\n    /**\r\n\t * @param {Object} watcher\r\n\t * 给属性的dep收集器记录收集了多少个watcher，并将watcher存放在subs数组中\r\n\t * 其实就是记录这个属性有多少个组件模板在引用\r\n\t */\r\n    addSub(watcher){\r\n        this.subs.push(watcher);\r\n    }\r\n\r\n    /**\r\n     * 属性setter时：属性的dep对其依赖的watcher进行通知，让watcher依次进行更新\r\n     */\r\n    notify(){\r\n        this.subs.forEach(watcher=>{\r\n            watcher.update();\r\n        })\r\n    }\r\n}\r\n\r\n/* \r\n    1. 给Dep类添加一个静态属性target，表示依赖收集的目标，初始化为null\r\n    2. 静态属性就代表Dep上只有一份\r\n*/\r\nDep.target = null;\r\n\r\n/* \r\n    存放渲染watcher和计算属性watcher的栈\r\n*/\r\nlet stack = [];\r\n\r\n/* \r\n    将watcher入栈，同时将Dep.target指针指向最新放进来的那个watcher\r\n*/\r\nexport function pushTarget(watcher){\r\n    stack.push(watcher);\r\n    Dep.target = watcher;\r\n}\r\n\r\n/* \r\n    将watcher出栈，同时将Dep.target指针指向当前栈顶的那个watcher\r\n*/\r\nexport function popTarget(){\r\n    stack.pop();\r\n    Dep.target = stack[stack.length-1];\r\n}\r\n\r\nexport default Dep;","import Dep from \"./dep\";\r\n\r\n// 传递过来的是data引用空间\r\nexport function observe(data) {\r\n  // 只有对象才可以劫持 如果不是对象 那么不用劫持\r\n  if (typeof data !== \"object\" || data === null) return;\r\n\r\n  // 如果一个对象的__ob__属性存在并且是Observer的实例 那么说明这个对象已经被观测过了\r\n  if (data.__ob__ instanceof Observer) {\r\n    return data.__ob__;\r\n  }\r\n  // new Observer(data)函数调用的过程就是劫持data对象上属性的过程\r\n  return new Observer(data);\r\n}\r\n\r\n// 观测数组和对象的类\r\nclass Observer {\r\n  constructor(data) {\r\n    /* \r\n\t\t\t这里的data可能是一个数组 也可能是一个对象\r\n\t\t\t我们除了对数组和对象内部的每一项进行属性劫持\r\n\t\t\t还需要对数组和对象本身进行依赖收集 用来实现vm.arr.push(xxx)更新视图的效果\r\n\t\t\t给Observer的实例挂载一个dep属性用来进行依赖收集\r\n\t\t*/\r\n    this.dep = new Dep();\r\n\r\n    // 让__ob__属性的可被遍历属性设置为false 避免被遍历到从而引起死循环\r\n    Object.defineProperty(data, \"__ob__\", {\r\n      value: this,\r\n      enumrable: false,\r\n      configurable: false,\r\n    });\r\n\r\n    if (Array.isArray(data)) {\r\n      // 会将数组的7个可修改自身的方法调用进行劫持\r\n      let newArrayProto = createNewArrayProto();\r\n      data.__proto__ = newArrayProto;\r\n\r\n      // 会将数组中的对象的属性进行劫持\r\n      this.observeArray(data);\r\n    } else {\r\n      this.walk(data);\r\n    }\r\n  }\r\n\r\n  // 遍历对象 对属性依次进行劫持\r\n  walk(data) {\r\n    Object.keys(data).forEach((key) => {\r\n      // 单独定义  公共 方便导出 不放在类上\r\n      defineReactive(data, key, data[key]);\r\n    });\r\n  }\r\n\r\n  // 对数组中每一项进行观测\r\n  observeArray(data) {\r\n    data.forEach((item) => {\r\n      observe(item);\r\n    });\r\n  }\r\n}\r\n\r\n/* \r\n\t递归对数组中的数组本身进行依赖收集\r\n\titem.__ob__的值就是一个Observe对象\r\n*/\r\nfunction dependArray(value) {\r\n  for (const item of value) {\r\n    item.__ob__ && item.__ob__.dep.depend();\r\n    if (Array.isArray(item)) {\r\n      dependArray(item);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * 把对象target上的所有属性重新定义成为响应式数据\r\n * 为什么不放在类Observer上，为的是将这个方法可以单独导出在其他地方使用\r\n */\r\nfunction defineReactive(target, key, value) {\r\n  // 递归劫持 如果对象的属性值还是一个对象\r\n  let childOb = observe(value);\r\n\r\n  // 每一个属性key都有一个依赖收集器dep 闭包不销毁\r\n  let dep = new Dep();\r\n  // console.log('dep-key',key,dep);\r\n\r\n  Object.defineProperty(target, key, {\r\n    // 拦截取值操作\r\n    get() {\r\n      // console.log(`拦截了属性 ${key} 读取操作，当前属性的值是${value}`);\r\n      /* \r\n\t\t\t\t如果Dep.target有值,则进行依赖收集：\r\n\t\t\t\t1. 说明有一个渲染watcher实例调用了get方法执行渲染\r\n\t\t\t\t2. 并且将自身实例放在了Dep.target属性上\r\n\t\t\t\t3. 那么我们需要让属性依赖收集器dep记住这个watcher\r\n\t\t\t\t4. 让属性和watcher产生关联，执行dep.depend方法，属性dep收集到1个watcher\r\n\t\t\t*/\r\n      if (Dep.target) {\r\n        dep.depend();\r\n\r\n        // 让数组和对象本身也实现依赖收集\r\n        if (childOb) {\r\n         childOb.dep.depend();\r\n\r\n          //   如果值是数组 需要对数组中的每一个数组本身再执行Observe\r\n          if (Array.isArray(value)) {\r\n            dependArray(value);\r\n          }\r\n        }\r\n      }\r\n      return value;\r\n    },\r\n    // 拦截赋值操作\r\n    set(newValue) {\r\n      // console.log(`拦截了属性 ${key} 存值操作，新属性的值是${newValue}`);\r\n      if (newValue === value) return;\r\n\r\n      // 如果新赋的值是一个新的对象 还需要递归劫持\r\n      observe(newValue);\r\n      value = newValue;\r\n\r\n      // 属性值被修改的时候，当前属性的依赖收集器dep通知其收集的依赖watcher进行更新渲染\r\n      dep.notify();\r\n    },\r\n  });\r\n}\r\n\r\nfunction createNewArrayProto() {\r\n  let oldArrayProto = Array.prototype;\r\n  // 创建一个原型指向数组原型的空对象\r\n  let newArrayProto = Object.create(oldArrayProto);\r\n\r\n  // 以下7个方法会改变原数组\r\n  let methods = [\r\n    \"push\",\r\n    \"pop\",\r\n    \"shift\",\r\n    \"unshift\",\r\n    \"sort\",\r\n    \"reverse\",\r\n    \"splice\",\r\n  ];\r\n\r\n  methods.forEach((method) => {\r\n    newArrayProto[method] = function (...args) {\r\n      // console.log('监听到调用了数组方法', method);\r\n      let result = oldArrayProto[method].call(this, ...args);\r\n\r\n      // 需要对操作数组方法的时候新增的数据 再次进行劫持\r\n      let inserted;\r\n      switch (method) {\r\n        case \"push\":\r\n        case \"unshift\":\r\n          inserted = args;\r\n          break;\r\n        case \"splice\":\r\n          inserted = args.slice(2);\r\n          break;\r\n        default:\r\n          break;\r\n      }\r\n      // console.log('inserted', inserted);\r\n\r\n      if (inserted) {\r\n        // 对新增的内容再次进行劫持\r\n        this.__ob__.observeArray(inserted);\r\n      }\r\n\r\n      // 监听到数组调用方法修改了原数组通知对应的watcher 执行视图更新\r\n      this.__ob__.dep.notify();\r\n\r\n      return result;\r\n    };\r\n  });\r\n\r\n  return newArrayProto;\r\n}\r\n","/**\r\n * @param {Object} vm Vue实例对象\r\n * @param {Object} target 要代理的vm上的目标对象_data = {}\r\n * @param {Object} key 目标对象的属性 name\r\n * 实现访问vm.name = 访问vm._data.name\r\n */\r\n export function proxy(vm, target, key) {\r\n\tObject.defineProperty(vm, key, {\r\n\t\tget() {\r\n\t\t\treturn vm[target][key];\r\n\t\t},\r\n\t\tset(newValue) {\r\n\t\t\tvm[target][key] = newValue;\r\n\t\t}\r\n\t})\r\n}","import {observe} from '../observer/index.js'\r\nimport {proxy} from '../observer/proxy.js'\r\n\r\n/**\r\n * 1. 获取数据\r\n * 2. 对获取到的data进行响应式处理\r\n */\r\nexport function initData(vm) {\r\n\r\n\tlet data = vm.$options.data;\r\n\t// data可能是函数可能是对象\r\n\tdata = typeof data === 'function' ? data.call(vm) : data;\r\n\r\n\t// 将要劫持的对象放在实例上 便于观测效果\r\n\tvm._data = data;\r\n\t\r\n\t// 对data数据进行响应式处理\r\n\tobserve(data);\r\n\r\n\t// 数据代理\r\n\tfor (let key in data) {\r\n\t\tproxy(vm, '_data', key);\r\n\t}\r\n\r\n}","/* \r\n    nextTick并没有直接采用某一个API \r\n    而是采用了优雅降级的方式来实现\r\n    并且这里采用了一个策略模式来实现给timerFunction的赋值\r\n\r\n    原则为尽可能快的看到视图发生刷新：\r\n    Promise.resolve()\r\n    MutationObserver\r\n    setImmediate\r\n    setTimeout\r\n\r\n*/\r\nlet timerFunction = null;\r\nfunction getTimerFunction(){\r\n    if(Promise && typeof Promise === 'function'){\r\n        timerFunction = ()=>{\r\n            Promise.resolve().then(flashCallBacks);\r\n        }\r\n    }else if(MutationObserver){\r\n        let mutationOb = new MutationObserver(flashCallBacks);\r\n        let textNode = document.createTextNode(1);\r\n        mutationOb.observe(textNode,{\r\n\t\t\tcharacterData:true\r\n\t\t})\r\n        timerFunction = ()=>{\r\n\t\t\ttextNode.textContent = 2;\r\n\t\t}\r\n    }else if(setImmediate){\r\n        timerFunction = ()=>{\r\n\t\t\tsetImmediate(flashCallBacks);\r\n\t\t}\r\n    }else{\r\n        timerFunction = ()=>{\r\n\t\t\tsetTimeout(flashCallBacks,0);\r\n\t\t}\r\n    }\r\n}\r\ngetTimerFunction();\r\n\r\n/**\r\n * 异步批处理\r\n */\r\nlet callBacks = [];\r\nlet waiting = false;\r\n\r\nexport function nextTick(callback) {\r\n    console.log('nextTick执行，先缓存callback\\n',callback)\r\n\r\n    // 异步批处理：先在这里全部缓存起来\r\n    callBacks.push(callback);\r\n    if(!waiting){\r\n        /* \r\n            等到时间到了才依次将任务取出执行\r\n            cb() => \r\n            flushSchedulerQuene() => \r\n            flushWatcherQuene.forEach(watcher=>{watcher.run();}) =>\r\n            watcher.get() 视图更新\r\n        */\r\n       /*  \r\n            setTimeout(()=>{\r\n                flashCallBacks();\r\n            },0) \r\n            waiting = true;\r\n        */\r\n        timerFunction();\r\n        waiting = true;\r\n    }\r\n}\r\n\r\n/* \r\n    将任务队列中任务取出依次执行\r\n*/\r\nfunction flashCallBacks(){\r\n    let cbs = callBacks.slice(0);\r\n    callBacks = [];\r\n    waiting = false;\r\n    cbs.forEach((cb)=>{\r\n        cb();\r\n    })\r\n}\r\n\r\n\r\n","/* \r\n    1. 将渲染逻辑封装到Watcher类中\r\n\r\n    2. 每一个watcher都需要有id进行标记和其他watcher进行区分，因为Vue中的每一个组件都有一个watcher\r\n        假设A组件中的watcher依赖了name属性和age属性\r\n        假设B组件中的watcher依赖了age属性\r\n        假设C组件中的watcher依赖了num属性\r\n\r\n        如果现在只有name属性发生了变化，那么name属性的Dep收集器难道要通知所有watcher更新吗？很显然B组件和C组件是不需要更新的\r\n\r\n        我们只需要更新A组件即可，那么如何区分呢?就需要对watcher进行唯一id标识。\r\n        每次创建watcher实例都将id进行累加标记\r\n\r\n    这也是我们组件化的目的：\r\n        1. 复用\r\n        2. 易维护\r\n        3. 局部更新(如果一个页面就只有一个watcher，那么不管任意一个属性发生变化，都会导致watcher更新引起视图渲染，如果一个页面中有多个组件，每个组件都有自己的watcher，那么它只用更新自己的部分)\r\n\r\n    3. watcher的作用就是封装渲染逻辑,它的实例属性有：\r\n\r\n    + id 为了标识watcher，以便于区分不同的watcher\r\n    + getter \r\n    为了保存vm的渲染逻辑函数，以后只要调用watcher上的getter，就等于执行渲染\r\n    默认在new Wacther的时候需要做一次初渲染  也就是默认调用一次getter\r\n    调用getter函数就等于调用渲染逻辑updateComponent\r\n    就等于调用_update和_render\r\n    那么_render在执行生成虚拟DOM的过程中就会去读取vm实例上的属性\r\n    最后会触发属性的getter\r\n\r\n*/\r\nimport Dep, { pushTarget, popTarget } from \"./dep\";\r\nimport { nextTick } from \"./nextTick.js\";\r\n\r\nlet id = 0;\r\nclass Watcher {\r\n  /* \r\n        1. vm：需要告诉我当前这个watcher实例是那个vm实例的\r\n        2. exprOrFn：字符串或者函数,我们会将字符串转化为函数写法\r\n          值为字符串时，可能是vm.$watch(\"number\", cb);\r\n          值为函数，可能是初始化渲染updateCpmponent、计算属性getter以及vm.$watch(()=>vm.number, cb);\r\n        3. options 值为true的时候表示要创建一个渲染watcher\r\n        4. deps 存放当前watcher被哪些属性的dep所收集\r\n        5. depsId 存放当前watcher对应的依赖收集器的id集合\r\n        6. lazy 标识此watcher的fn是否为懒执行,也就是在new Watcher的时候先不执行\r\n        7. dirty 标识计算属性的watcher是否为脏 如果是脏的才会在触发计算属性自己getter的时候执行get方法\r\n        8. callback watch配置项中观察的属性变化时要执行的回调函数\r\n        9. user 标识是否为用户自己的watcher\r\n        10. value 执行this.get()方法的返回值 对于vm.$watch(()=>vm.number, cb)来说\r\n            就是执行()=>vm.number的返回值也就是vm.number的值，这个值就是watch观察的属性的老值oldValue\r\n        \r\n    */\r\n  constructor(vm, exprOrFn, options,callback) {\r\n    this.id = id++;\r\n    this.renderWatcher = options;\r\n    /* \r\n      将exprOrFn为字符串统一转化为函数\r\n    */\r\n    if(typeof exprOrFn === 'string'){\r\n      this.getter = function(){\r\n        return vm[exprOrFn];\r\n      }\r\n    }else{\r\n      this.getter = exprOrFn;\r\n    }\r\n    \r\n\r\n    this.deps = [];\r\n    this.depsId = new Set();\r\n\r\n    this.lazy = options.lazy;\r\n    this.dirty = this.lazy;\r\n    this.callback = callback;\r\n    this.vm = vm;\r\n    this.user = options.user;\r\n\r\n    /* 控制在new Watcher的时候传入的fn是立即执行还是懒执行 */\r\n    this.value = this.lazy ? null : this.get();\r\n  }\r\n\r\n  /* \r\n        执行get方法的流程：\r\n        0. 将当前watcher实例放到Dep.target属性上\r\n        1. this.getter();\r\n        2. 调用渲染逻辑updateComponent\r\n        3. 调用_update和_render\r\n        4. 调用_render的时候去vm上读取属性值\r\n        5. 触发getter，判断是否Dep.target有值，如果有值，执行dep依赖收集方法depend\r\n\r\n        name => dep.depned => [watcher]\r\n        age => dep.depend => [watcher]\r\n    */\r\n  get() {\r\n    // 将watcher实例赋值给Dep.target静态属性\r\n    //  Dep.target = this;\r\n    pushTarget(this);\r\n\r\n    /* \r\n       执行this.getter方法就会去vm实例上取值，触发属性的getter，进行依赖收集\r\n       1. 如果执行渲染getter，那么getter中的this本来也就是vm实例（之前通过with绑定的）\r\n       2. 如果执行计算属性的getter，那么getter中的this必须为vm实例才可以\r\n       3. 如果执行watch观察属性的fn，那么getter中的this必须为vm实例才可以\r\n    */\r\n    let value = this.getter.call(this.vm);\r\n    console.log(\r\n      \"this.getter执行一次，执行的watcher是\",\r\n      this,\r\n      \"\\n执行的结果是\",\r\n      value\r\n    );\r\n\r\n    // 必须清空 否则会导致不被模板依赖的属性发生getter的时候也被收集\r\n    // Dep.target = null;\r\n    popTarget(this);\r\n\r\n    // 如果是计算属性watcher 执行getter方法需要获取到计算后的返回值\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * watcher实例记录dep依赖收集器的方法\r\n   *\r\n   * 1. 一个组件(视图)watcher可能对应多个属性，每个属性都有自己的dep\r\n   * 2. 那么也就是说一个watcher应该记录自己被哪些dep所收集了\r\n   * 3. 对于重复的属性，watcher也不用重复记录，比如一个watcher中读取了两次name值\r\n   *    那么会触发两次name的getter\r\n   *    就会触发两次name属性的dep.depend方法\r\n   *    就会触发两次Dep.target.addDep(this);\r\n   *    就等于执行了两次watcher实例的addDep方法；\r\n   *    如果不去重，此watcher实例内部的deps就会记录到重复的name属性的dep\r\n   */\r\n  addDep(dep) {\r\n    const depId = dep.id;\r\n    // 基于set去重：如果dep的id没有存在于depIds的set中，那么才进行记录\r\n    if (!this.depsId.has(depId)) {\r\n      // 当前watcher实例对此属性依赖收集器dep 进行记录并且实现了dep的去重\r\n      this.deps.push(dep);\r\n\r\n      this.depsId.add(depId);\r\n\r\n      // 传递进来的属性依赖收集器dep实例对此watcher也进行依赖收集，间接实现了watcher去重\r\n      dep.addSub(this);\r\n    }\r\n  }\r\n\r\n  /* \r\n    调用update就会执行get方法\r\n    重新走执行get方法的流程如上所示\r\n  */\r\n  update() {\r\n    // 如果计算属性依赖的值发生变化了 就标识计算属性已经是脏值了,就不去走queneWatcher了\r\n    if (this.lazy) {\r\n      this.dirty = true;\r\n    } else {\r\n      // --- this.get(); 每次update更新会引起重复的更新 性能浪费 需要将更新操作先缓存\r\n      queneWatcher(this);\r\n    }\r\n  }\r\n\r\n  run() {\r\n    let oldValue = this.value;\r\n    let newValue = this.get();\r\n    if(this.user){\r\n      this.callback.call(this.vm,newValue,oldValue)\r\n    }\r\n   \r\n  }\r\n\r\n  /* \r\n    计算属性依赖的属性的dep记录Dep.target指向的上一层watcher(渲染watcher)\r\n    1. 如何通过watcher获取到关联的deps\r\n    2. 如果让这些deps分别记录到Dep.target\r\n  */\r\n  depend() {\r\n    // 获取有多少个属性的dep记录了此watcher 如果一个计算属性依赖了2个属性fName和lName\r\n    // 那么fName和lName属性的dep依赖收集器中收集了此watcher\r\n    for (let i = 0; i < this.deps.length; i++) {\r\n      const dep = this.deps[i];\r\n      // 让Dep.target指向的上一层watcher(渲染watcher)也被收集到属性的dep中\r\n      dep.depend();\r\n    }\r\n  }\r\n\r\n  /* \r\n    evaluate是计算的意思，是专门用来处理计算属性的，有三个作用：\r\n    1. 执行计算属性watcher的get方法，这个get其实就是计算属性的getter\r\n    2. 获取到上一步计算后的结果，也就是get方法的返回值，挂载到此watcher的value属性上\r\n    3. 同时修改此计算顺序watcher的dirty属性\r\n  */\r\n  evaluate() {\r\n    // 获取到用户传入函数的返回值\r\n    this.value = this.get();\r\n    this.dirty = false;\r\n  }\r\n}\r\n\r\n/**\r\n * 将需要更新的watcher缓存到队列中\r\n * @param {*} watcher\r\n */\r\nlet quene = []; // 缓存即将要更新的watcher队列\r\nlet has = {}; // 基于对象去重\r\nlet pending = false; // 实现防抖\r\nfunction queneWatcher(watcher) {\r\n  console.log(\"queneWatcher执行\");\r\n  const id = watcher.id;\r\n  if (!has[id]) {\r\n    // 将需要更新视图的watcher先暂存到队列中\r\n    quene.push(watcher);\r\n    has[id] = true;\r\n    console.log(\"当前保存watcher的队列为\", quene);\r\n\r\n    if (!pending) {\r\n      // 同步任务结束之后 依次调用watcher的run方法 然后清空缓存的watcher\r\n\r\n      // --- setTimeout(flushSchedulerQuene, 0);\r\n      nextTick(flushSchedulerQuene);\r\n      pending = true;\r\n    }\r\n  }\r\n}\r\n\r\n/* \r\n  刷新调度队列\r\n 把缓存在队列中的watcher拿出来，依次执行每一个watcher的更新视图操作\r\n*/\r\nfunction flushSchedulerQuene() {\r\n  let flushWatcherQuene = quene.slice(0);\r\n\r\n  // 清空队列\r\n  quene = [];\r\n  // 清空缓存\r\n  has = {};\r\n  // 重置pending 防止在下面run的时候产生了新的watcher 可以保证继续放入到队列quene中\r\n  pending = false;\r\n\r\n  // 依次执行watcher的run方法更新视图\r\n  flushWatcherQuene.forEach((watcher) => {\r\n    watcher.run();\r\n  });\r\n}\r\n\r\nexport default Watcher;\r\n","import Dep from \"../observer/dep\";\r\nimport Watcher  from \"../observer/watcher\";\r\n\r\nexport function initComputed(vm){\r\n    let computed = vm.$options.computed;\r\n    // 将计算属性关联的所有watcher保存到vm的_computedWatchers属性上便于后续从vm上取值\r\n    let watchers = vm._computedWatchers = {};\r\n    // 遍历用户传入的computed对象\r\n    for (const key in computed) {\r\n        if (Object.hasOwnProperty.call(computed, key)) {\r\n            /* \r\n                获取对计算属性的值\r\n                1. 值可能为对象 fullName:{get(){return xxx},set(){}}\r\n                2. 值可能为函数 fullName(){return xxx};\r\n            */\r\n            let userDefine = computed[key];  \r\n\r\n            /* \r\n                目的：将计算属性和watcher关联起来，并且保证这次new Watcher中的fn不执行\r\n                      此watcher用于监控计算属性中get的变化\r\n                    \r\n                getter:当计算属性本身为函数时就是本身，为一个对象时就是计算属性的get方法\r\n                lazy：默认当new Watcher的时候传入的第二个参数fn也就是getter会立即执行，但是我们希望\r\n                      计算属性的getter不立即执行，而是真正取值的时候才执行，也就是懒执行\r\n            */\r\n            let getter = typeof userDefine === 'function' ? userDefine:userDefine.get;\r\n            watchers[key] = new Watcher(vm,getter,{lazy:true})\r\n\r\n\r\n            /* \r\n                目的：将用户传入的计算属性挂载到vm实例对象上，方便可以直接通过vm访问计算属性\r\n            */\r\n            defineComputed(vm,key,userDefine);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * 定义计算属性：因为计算属性自己就有setter和getter\r\n * @param {*} target 要给vm实例定义计算属性\r\n * @param {*} key 计算属性的key，比如fullName\r\n * @param {*} userDefine 计算属性的值，也就是用户自定义传入的计算属性的值\r\n */\r\nfunction defineComputed(target,key,userDefine){\r\n\r\n    /* \r\n        取出计算属性的getter和setter\r\n    */\r\n    let getter = typeof userDefine === 'function' ? userDefine:userDefine.get;\r\n    let setter = userDefine.set || (()=>{});\r\n    // console.log(`计算属性${key}的\\ngetter是：${getter}\\nsetter是：${setter}\\n`);\r\n\r\n    /* \r\n        定义响应式属性\r\n    */\r\n    Object.defineProperty(target,key,{\r\n        get:createComputedGetter(key),\r\n        set:setter\r\n    })\r\n}\r\n\r\n/* \r\n    createComputedGetter:创建一个包装后的计算属性Getter，控制是否执行用户传入的getter\r\n\r\n    1. createComputedGetter方法的返回值是一个getter函数，此函数在调用时的this是target也就是vm实例\r\n    2. 当模板在第一次读取计算属性的值的时候就会触发其getter，此时就会执行此包装后的getter函数，如果和此计算属性关联的watcher是dirty也就是值为true，那么就执行getter返回值\r\n    3. 当模板第二次读取计算属性的值的时候，此时dirty已经被修改为false，就不会多次的执行计算属性真正的那个getter了(比如return this.fName + this.lName)\r\n*/\r\nfunction createComputedGetter(key){\r\n    return function(){\r\n        // 获取到initComputed时定义的此计算属性key对应的watcher\r\n        const watcher = this._computedWatchers[key];\r\n        \r\n        // 如果是脏的 就去执行watcher的evaluate方法 只要执行一次就将dirty变为false 下次再求值就不执行了\r\n        if(watcher.dirty){\r\n            console.log(\"计算属性watcher执行\");\r\n            watcher.evaluate();\r\n        }\r\n\r\n        /* \r\n            1. 如果watcher.evaluate()执行之后Dep.target还有值 那么说明计算属性出栈后还有渲染watcher在栈中\r\n            2. 此时需要找到计算属性中的依赖的属性（如fName和lName），让这些属性的dep不仅要收集计算属性watcher，还需要收集上一层的watcher(渲染watcher)\r\n            3.  这是修改计算属性依赖的属性而不修改计算属性引起视图渲染的核心所在\r\n        */\r\n        if(Dep.target){\r\n            // 让watcher反过来收集属性\r\n            watcher.depend();\r\n        }\r\n       \r\n        return watcher.value;\r\n    }\r\n}","export function initWatch(vm){\r\n    // 获取用户传入的watch配置项对象\r\n    let watchOptions = vm.$options.watch;\r\n\r\n    // 遍历每一个watch属性\r\n    for (let key in watchOptions) {\r\n        // 获取到watch属性key对应的值，可能为数组、字符串和函数\r\n        let handler = watchOptions[key];\r\n\r\n        // 如果值为数组 那么数组中有多个回调函数 遍历数组中的每一项调用vm.$watch\r\n        if(Array.isArray(handler)){\r\n            for (let i = 0; i < handler.length; i++) {\r\n                createWatcher(vm,key,handler[i]);\r\n            }\r\n        }else{\r\n            createWatcher(vm,key,handler);\r\n        }\r\n    }\r\n   \r\n}\r\n\r\n/**\r\n * 这一步的目的是将通过数组字符串以及函数写法的watch配置项转化成为统一的vm.$watch写法\r\n * 并且方法的第一个参数key一定为字符串\r\n * \r\n * @param {*} vm 实例\r\n * @param {*} key watch配置项中要观察的实例上的属性名\r\n * @param {*} handler 属性名发生变化之后要执行的回调\r\n */\r\nfunction createWatcher(vm,key,handler){\r\n    // 如果值为字符串 说明这个handler是调用了methdos中的方法 而methods上的函数最终也会挂载到vm上\r\n    if(typeof handler === \"string\"){\r\n        // 直接通过vm实例去获取函数\r\n        handler = vm[handler];\r\n    }\r\n    \r\n    return vm.$watch(key,handler);\r\n\r\n}","import {initData} from './initData.js';\r\nimport {initComputed} from \"./initComputed.js\";\r\nimport {initWatch} from \"./initWatch.js\"\r\n\r\nexport function initState(vm) {\r\n\tlet options = vm.$options; // 获取用户传入的选项\r\n\t\r\n\t// 初始化的顺序应该是固定的\r\n\t\r\n\tif (options.props) {\r\n\t\tinitProps(vm);\r\n\t}\r\n\r\n\tif (options.data) {\r\n\t\tinitData(vm);\r\n\t}\r\n\r\n\tif (options.methods) {\r\n\t\t// initMethods(vm);\r\n\t}\r\n\r\n\tif (options.computed) {\r\n\t\tinitComputed(vm);\r\n\t}\r\n\r\n\tif (options.watch) {\r\n\t\tinitWatch(vm);\r\n\t}\r\n}\r\n\r\n","/* \r\n    由于Vue2.0中的HTML模板解析是基于正则表达式来实现的，\r\n    所以这个模块专门用来存放所有模板解析过程中遇到的正则表达式。\r\n    从Vue3.0开始摒弃了正则表达式解析模板的方法，而是采用了字符逐个判断的方法来实现的。\r\n\r\n    对于任意正则表达式，只有两个功能：\r\n    1. 对一段字符串进行匹配校验，看这个字符串是否符合正则，返回的是布尔值\r\n    2. 找出一段字符串中符合正则校验的内容，也就是正则捕获\r\n\r\n    这里面的大多数正则就是为了捕获模板字符串中的开始标签、结束标签、标签属性以及双大括号内部的表达式的。\r\n\r\n*/\r\n\r\n/**\r\n * 1. ncname\r\n * ncname只是一个字符串，要将字符串转化为正则还需要使用new RegExp进行转换，字符串中的/必须用//表示\r\n *\r\n * 用于专门匹配标签名称的正则，注意不是标签全部而是标签名称\r\n * 比如标准标签：div,h1,p,span等\r\n * 还有自定义标签：table-el,cmdb-tree,hello.tree\r\n *\r\n * 1. 第一位必须以英文字母和下划线\r\n * 2. 开头后面可能有可能没有，比如b标签这种单字母标签\r\n * 3. 如果有那么可以是以数字、字母、下划线、中横线-和点.\r\n */\r\nconst ncname = `[a-zA-Z_][\\\\-\\\\.0-9a-zA-Z_]*`;\r\n\r\n/**\r\n * 2. qnameCapture：捕获开始标签和结束标签名称\r\n *\r\n * qnameCapture是一个字符串，用在正则中便具有了可以捕获的作用，因为其内部有小括号\r\n * 专门用来从一串html字符串中捕获匹配到的标签名称分组内容的\r\n * 这里还考虑到了命名空间的标签比如：<div:hello>\r\n * 对于这样一个标签<div:hello></div:hello> 这个正则可以捕获到div:hello这个名称\r\n * 对于这样一个标签<div></div> 这个正则可以捕获到div这个标签名称\r\n */\r\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`;\r\n\r\n/**\r\n * 3. startTagOpen：可以匹配到字符串中的开始标签如<div，目的是捕获到开始标签名称div\r\n *\r\n * 比如字符串<div></div> 会匹配到<div,分组会捕获到字符串div,这个div就是组成AST抽象语法树的tag属性。\r\n *\r\n * 解析正则：\r\n * 1. 标签必须以<开头\r\n * 2. 标签名称不可以以数字开头，必须以数字字母瞎下划线开头\r\n * 3. 标签名称除了首字母之外，还可以是数字、字母、下划线、中横线-和点.\r\n *    比如自定义标签<_div> <table-el> <div.demo>\r\n * 4. HTML标签有两种，常见的比如<div>，还有不常见的带有命名空间的标签比如：<div:hello>\r\n *    在web component中定义的自定义标签会出现这种情况\r\n *\r\n */\r\nconst startTagOpen = new RegExp(`^<${qnameCapture}`);\r\n\r\n/**\r\n * 4. endTag: 专门用来匹配html结束标签的正则，在匹配成功会捕获到结束标签的名称\r\n * 和开始标签一样，对于</div>这种普通标签，会匹配到</div>，捕获到div\r\n * 对于<br/>和<hr/>这种自己闭合的标签，会匹配为空，因为会被当做开始标签解析\r\n */\r\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`);\r\n\r\n/**\r\n * 5. startTagClose： 专门用来匹配开始标签闭合的正则\r\n * 比如可以匹配成功 结束标签<div>，会匹配到>符号\r\n * 比如可以匹配成功 自闭合标签<br/>，会匹配到/>符号\r\n *\r\n *\r\n * \\s* 可以有0个或多个空白字符开头\r\n * (\\/?)>  匹配 />\r\n */\r\nconst startTagClose = /^\\s*(\\/?)>/;\r\n\r\n/**\r\n * 6. attribute：专门用来匹配和捕获标签内的属性键值对的正则\r\n *     由于此正则存在多个分组，但是最终我们需要的是：\r\n * 第一个分组$1，存放的是属性的key\r\n * 第三、四、五分组，分别存放的是属性的值\r\n *\r\n * 1. ^\\s* 可以以空白字符开始\r\n *\r\n * 2. ([^\\s\"'<>\\/=]+) 后续不能存在这些特殊字符 可以是除了这些字符的一个或多个字符组成的属性key\r\n *\r\n * 3. (?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?\r\n *      ?: 整体分组是只匹配不捕获的\r\n *      ?  整体可以出现一次或多次\r\n *\r\n *  3.1  \\s*(=)\\s* 键值对以=号连接，前面左右两边可以有空白字符，比如: name =   job\r\n *  3.2  () ?:整体分组是只匹配不捕获的\r\n *      \"([^\"]*)\"+ 左右边都是双引号，中间不是双引号的就可以匹配，比如color=\"red\"\r\n *      |代表或者的意思\r\n *      '([^']*)'+ 左右边都是单引号，中间不是单引号的就可以匹配，比如fontSize='18px'\r\n *      |代表或者的意思\r\n *      ([^\\s\"'=<>`]+) 只要不是空白字符 \" ' = < > `，其余的任意字符组成的一个或多个单词都可以匹配，比如data-src=demo\r\n *  3.3 还可以只有属性名没有属性值，比如<input disabled>这种也符合html语法\r\n */\r\nconst attribute =\r\n  /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\r\n\r\n/**\r\n * 7. defaultTagReg ： 用来匹配双大括号语法的正则，可以捕获到内部的表达式，全局匹配\r\n *\r\n * ((?:.|\\r?\\n)+?)\r\n * 最后的?更在量词元字符后面，代表取消正则捕获的贪婪性，只捕获最短的符合条件的字符即可\r\n * (?:.|\\r?\\n)+\r\n * 开头的?:表示对该小分组只匹配不捕获\r\n * .表示除了\\n换行符之外的任意字符\r\n * 或者\r\n * \\r?\\n 0个或一个回车符号后面跟这个换行符\r\n *\r\n * {{any char}} 表示可以匹配任意双大括号语法，并且会捕获到里面的表达式\r\n *\r\n */\r\nconst defaultTagReg = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\r\n\r\n\r\nexport {\r\n    startTagOpen,\r\n    startTagClose,\r\n    endTag,\r\n    attribute,\r\n    defaultTagReg\r\n}","import { startTagOpen, startTagClose, endTag, attribute } from \"./tagReg.js\";\r\n\r\n/**\r\n * parseHTML方法 htmlparser2等于手写了\r\n *\r\n *\r\n * 1. 功能：将html语法表达的html模板字符串转化为JS语法表达的AST抽象语法树\r\n *\r\n * 2. 解析思路：\r\n * 不停基于正则对htmlStr进行解析，每次匹配到一部分内容就从原始htmlStr中将其删除\r\n * 最终等到htmlStr截取为空字符串的时候，标志着模板解析完成。\r\n * 在解析的过程中会逐渐将AST抽象语法树构建起来。\r\n */\r\n\r\nconst ELEMENT_TYPE = 1;\r\nconst TEXT_TYPE = 3;\r\n\r\nexport function parseHTML(htmlStr) {\r\n  let root;\r\n  let tagStack = [];\r\n  let currentParent = null;\r\n\r\n  const onParseStartTag = function (tagName, attrs) {\r\n    const astNode = createASTElement(tagName, attrs);\r\n    if (!root) {\r\n      root = astNode;\r\n    }\r\n\r\n    // 如果指向栈顶指针有节点 要将当前解析后新建的astNode当做子节点加入到当前节点的children中\r\n    if (currentParent) {\r\n      // astNode的父节点引用指向栈顶\r\n      astNode.parent = currentParent;\r\n      // 父节点将astNode加入子节点数组中 是双向奔赴的行为\r\n      currentParent.children.push(astNode);\r\n    }\r\n\r\n    tagStack.push(astNode);\r\n    currentParent = astNode;\r\n  };\r\n\r\n  const onParseText = function (text) {\r\n    text = text.replace(/\\s/g, \"\");\r\n    // 父节点将文本节点加入子节点数组中\r\n    text &&\r\n      currentParent.children.push({\r\n        text,\r\n        nodeType: TEXT_TYPE,\r\n        parent: currentParent,\r\n      });\r\n  };\r\n\r\n  const onParseEndTag = function (tagName) {\r\n    let topNodeElement = tagStack.pop();\r\n    if (topNodeElement.tag !== tagName) {\r\n      console.error(\"输入的标签不合法!\");\r\n    }\r\n    currentParent = tagStack[tagStack.length - 1];\r\n  };\r\n\r\n  /**\r\n   * 将htmlStr字符串从索引为startIndex的地方截取至末尾，并给原始htmlStr字符串赋值\r\n   */\r\n  const advance = function (startIndex) {\r\n    htmlStr = htmlStr.slice(startIndex);\r\n  };\r\n\r\n  /**\r\n   *  解析开始标签，要求解析的产物是开始标签的名称tagName和开始标签的属性attrs数组\r\n   */\r\n  const parseStartTag = function () {\r\n    const startTagOpenMatchResult = htmlStr.match(startTagOpen);\r\n    if (startTagOpenMatchResult) {\r\n      // console.log(\"startTagOpenMatchResult\", startTagOpenMatchResult);\r\n\r\n      // 解析的产物\r\n      const parseResult = {\r\n        tagName: startTagOpenMatchResult[1],\r\n        attrs: [],\r\n      };\r\n      advance(startTagOpenMatchResult[0].length);\r\n\r\n      // 解析开始标签中的属性和末尾的右尖角号,只要没有遇到结束的右尖角号就一直解析属性\r\n      let attrMatchResult;\r\n      let startTagCloseMatchResult;\r\n      while (\r\n        !(startTagCloseMatchResult = htmlStr.match(startTagClose)) &&\r\n        (attrMatchResult = htmlStr.match(attribute))\r\n      ) {\r\n        // console.log(\"attrMatchResult\", attrMatchResult);\r\n        advance(attrMatchResult[0].length);\r\n        parseResult.attrs.push({\r\n          name: attrMatchResult[1],\r\n          value:\r\n            attrMatchResult[3] ||\r\n            attrMatchResult[4] ||\r\n            attrMatchResult[5] ||\r\n            true,\r\n        });\r\n      }\r\n\r\n      if (startTagCloseMatchResult) {\r\n        advance(startTagCloseMatchResult[0].length);\r\n      }\r\n      return parseResult;\r\n    }\r\n    return false;\r\n  };\r\n\r\n  const createASTElement = function (tag, attrs) {\r\n    return {\r\n      tag,\r\n      attrs,\r\n      nodeType: ELEMENT_TYPE,\r\n      parent: null,\r\n      children: [],\r\n    };\r\n  };\r\n\r\n  while (htmlStr !== \"\") {\r\n    let textEndIndex = htmlStr.indexOf(\"<\");\r\n\r\n    // 开始标签<div> 或者 结束标签</div>\r\n    if (textEndIndex === 0) {\r\n      let startTagParseResult = parseStartTag();\r\n      //  说明当前htmlStr的开头第一个字符是开始标签的<\r\n      if (startTagParseResult) {\r\n        let { tagName, attrs } = startTagParseResult;\r\n        onParseStartTag(tagName, attrs);\r\n        continue;\r\n      }\r\n\r\n      let endTagParseResult = htmlStr.match(endTag);\r\n      //  说明当前htmlStr的开头第一个字符是结束标签的<\r\n      if (endTagParseResult) {\r\n        advance(endTagParseResult[0].length);\r\n        onParseEndTag(endTagParseResult[1]);\r\n        continue;\r\n      }\r\n    }\r\n\r\n    // 说明textEndIndex就是标签内部文本结束位置\r\n    if (textEndIndex > 0) {\r\n      const text = htmlStr.slice(0, textEndIndex);\r\n      if (text) {\r\n        onParseText(text);\r\n        advance(text.length);\r\n      }\r\n    }\r\n  }\r\n\r\n  // console.log(\"当前模板字符串 ====>\\n\", htmlStr === \"\"); // true 说明解析完成\r\n\r\n  // console.log(\"解析模板的产物AST语法树是 === >\\n\", root);\r\n\r\n  return root;\r\n}\r\n\r\n/* \r\n    总体解析思路：\r\n\r\n    入口：从<字符的 indexOf返回值开始解析\r\n        =0  解析到了一个开始标签<div>或者结束标签</div>\r\n        >0 \r\n\r\n    不能光删 需要边删除边构建AST抽象语法树\r\n    root:{\r\n        tag:\"div\",\r\n        arrts:[],\r\n        children:[\r\n            {\r\n                tag:\"p\",\r\n                arrts:[],\r\n                children：\"你好啊，李银河！\"\r\n                parent:div\r\n            }，\r\n             {\r\n                tag:\"div\",\r\n                arrts:[],\r\n                children：[\r\n                    {\r\n                        tag:\"span\",\r\n                        arrts:[],\r\n                        children：\"span标签\"\r\n                        parent:div\r\n                    }\r\n                ]\r\n                parent:div\r\n            }\r\n        ],\r\n        parent:null\r\n    }\r\n*/\r\n\r\n/* \r\n    父子关系的确定 基于栈 这是栈的应用\r\n\r\n    当前解析的标签tagName的父亲就是栈顶元素的儿子\r\n    遇到结束标签就出栈\r\n    遇到开始标签就入栈，确定父子关系\r\n\r\n    基于正则和while循环进行解析\r\n    基于栈维护关系\r\n    进栈就构建父子关系\r\n    出栈就维护栈顶指针\r\n    出来AST抽象语法树\r\n*/\r\n","import { defaultTagReg } from \"./tagReg.js\";\r\n\r\n\r\n/**\r\n *  generatorProps：专门用于生成属性字符串的方法\r\n *  输入节点的attrs，返回一个拼接好的属性值组成的字符串\r\n *  比如输入如下attrs属性数组：\r\n *  [\r\n *      {name: 'id', value: 'app'}, \r\n *      {name: 'style', value: 'color: pink;font-size: 18px;'}\r\n *  ];\r\n *  \r\n *  返回一个拼接后的propsStr字符串：\r\n *  {id:\"app\",style:{\"color\":\"pink\",\"font-size\":\"18px\"}}\r\n * \r\n */\r\nfunction generatorProps(attrs){\r\n    let propsStr = \"\";\r\n    for (const attr of attrs) {\r\n        let {name,value} = attr;\r\n        if(name === 'style'){\r\n            let styleObj = {};\r\n\r\n            // 把诸如 value: 'color: pink;font-size: 18px;'中最后一个;切割掉 便于后续拆分字符串为数组\r\n            if(value[value.length-1] === \";\"){\r\n                value = value.slice(0,-1);\r\n            }\r\n\r\n            // 继续拆分\r\n            value.split(\";\").forEach(item=>{\r\n                let [k,v] = item.split(\":\");\r\n                styleObj[k.trim()] = v.trim();\r\n            })\r\n            // console.log('styleObj',styleObj)\r\n            value = styleObj;\r\n        }\r\n        propsStr += `${name}:${JSON.stringify(value)},`;\r\n    }\r\n\r\n    // console.log(\"拼接的属性字符串为：\",propsStr.slice(0,-1))\r\n    return `{${propsStr.slice(0,-1)}}`\r\n}\r\n\r\n\r\nfunction generatorChildren(children){\r\n    if(children.length > 0){\r\n        return children.map(astNode=>generatorChild(astNode)).join(\",\");\r\n    }\r\n}\r\n\r\nfunction generatorChild(astNode){\r\n    const ELEMENT_TYPE = 1;\r\n    const TEXT_TYPE = 3;\r\n\r\n    if(astNode.nodeType === ELEMENT_TYPE){\r\n        return codeGenerator(astNode);\r\n    }\r\n\r\n    if(astNode.nodeType === TEXT_TYPE){\r\n        let content = astNode.text;\r\n        if(!defaultTagReg.test(content)){\r\n            return `_v(${JSON.stringify(content)})`;\r\n        }else{\r\n            // {{name}} hahah\r\n            // xixi {{name}} hahah {{age}} wuwu\r\n            let tokens = [];\r\n            let defaultTagMatchRes;\r\n            let lastIndex = 0;\r\n\r\n            defaultTagReg.lastIndex = 0; // 消除全局g正则捕获的懒惰性,避免由于test的判断导致lastIndex发生偏移\r\n\r\n            while(defaultTagMatchRes = defaultTagReg.exec(content)){\r\n                // 获取匹配双大括号的开始索引\r\n                let matchStartIndex = defaultTagMatchRes.index;\r\n\r\n                // 说明双大括号前还有文本，那么要将这段文本截取到tokens中用于未来拼接，比如xixi、hahah\r\n                if(matchStartIndex - lastIndex > 0){\r\n                    tokens.push(JSON.stringify(content.slice(lastIndex,matchStartIndex)));\r\n                }\r\n\r\n                // 获取捕获结果也就是双大括号中的表达式，需要去除空格之后用_s包裹 name age\r\n                let token = defaultTagMatchRes[1];\r\n                tokens.push(`_s(${token.trim()})`);\r\n\r\n                // 手动修正lastIndex的位置，便于下一次截取非{{}}的字符 \r\n                lastIndex = matchStartIndex + defaultTagMatchRes[0].length;\r\n            }\r\n\r\n            // 说明还有文本没有处理完\r\n            if(lastIndex < content.length){\r\n                tokens.push(`${JSON.stringify(content.slice(lastIndex))}`);\r\n            }\r\n\r\n            return `_v(${tokens.join(\"+\")})`;\r\n\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\nexport function codeGenerator(astTree) {\r\n    // console.log(\"输入的是AST抽象语法树===>\\n\",astTree);\r\n    let childrenCode = generatorChildren(astTree.children);\r\n\r\n    const code = `_c(\"${astTree.tag}\",${astTree.attrs.length > 0 ? generatorProps(astTree.attrs): null}${astTree.children.length > 0 ? `,${childrenCode}`: \"\"})`\r\n\r\n    // console.log(\"返回的是render函数字符串\",code);\r\n    return code;\r\n\r\n}\r\n\r\n\r\n/* \r\n    最终生成一个render函数，接收一个函数h当做参数\r\n    render(h){\r\n        return h(\"div\",{id:\"app\"},h('div',{style:{color:\"red\"}},_v(_s(name) + 'hello')));\r\n    }\r\n\r\n    h方法其实在源码里面就是_c,所以最终我们希望得到一个这样的render函数：\r\n    render(){\r\n        return _c(\"div\",{id:\"app\"},\r\n            _c('div',{style:{color:\"pink\"}},_v(_s(name) + 'hello')),\r\n            _c('span',null,_v(_s(age))),\r\n            _c('p',null,_v(_s(address.country)))\r\n        );\r\n    }\r\n\r\n    _c(\"div\",{id:\"app\"},_c(\"div\",{style:{\"color\":\"pink\",\"font-size\":\"18px\"}},_v(_s(name)+\"hello\")),_c(\"span\",null,_v(_s(age))),_c(\"p\",null,_v(_s(address.country))))\r\n\r\n    _c就是createElement(el,attrs,...children)\r\n        el是标签名称\r\n        attrs是属性对象\r\n        后面都是子节点\r\n\r\n    _v就是专门渲染表达式的\r\n    _s就是JSON.stringify 对表达式内的变量进行转义，避免出现对象和字符串相加变为[object Object]\r\n\r\n    要想得到类似这样的render函数，份两步走：\r\n    1. 先得到一个包含_c、_v和_s方法的字符串\r\n    2. with绑定vm实例，将表达式中的变量进行读取替换，比如将name替换为实例上的'lilei'\r\n    3. 通过new Function(fnString)的方式创建render函数\r\n\r\n    创建出来render函数这一步就ok了，就完成任务了，后面就是执行render函数返回vNode虚拟DOM了\r\n\r\n    所以我们codeGenerator的任务就是：\r\n    输入astTree这样一个JS对象\r\n    返回的产物是这样一个render函数字符串：其实就是字符串的拼接\r\n    render(){\r\n        return _c(\"div\",{id:\"app\"},\r\n            _c('div',{style:{color:\"pink\"}},_v(_s(name) + 'hello')),\r\n            _c('span',null,_v(_s(age))),\r\n            _c('p',null,_v(_s(address.country)))\r\n        );\r\n    }\r\n\r\n*/\r\n","import { parseHTML } from \"./htmlParser.js\";\r\nimport {codeGenerator} from './codeGenerator.js';\r\n\r\n\r\n/**\r\n * \r\n * @param {String} templateString 模板字符串\r\n * @return {Function} render函数\r\n */\r\nexport function compileToFunction(templateString){\r\n    // console.log('原始模板字符串 =====>\\n',templateString);\r\n    \r\n    /* \r\n        1. 模板编译第一步：解析HTML模板字符串templateString为AST抽象语法树\r\n    */\r\n    const astTree = parseHTML(templateString);\r\n\r\n    /* \r\n        2. 模板编译第二步：将AST抽象语法树生成带有_c、_v、_s的字符串\r\n    */\r\n    const code = codeGenerator(astTree);\r\n\r\n\r\n    /* \r\n        3. 模板编译第三步：将字符串通过new Function生成render函数\r\n        如何将代码字符串运行，目前有两种方案：\r\n        + eval()\r\n        + new Function() \r\n\r\n        通过new Function生成函数之后，函数体里面的name、age等变量从this上取值，\r\n        最后调用这个render函数的时候通过call绑定this即可：renderFn.call(vm)\r\n        这样就实现了去vm上取变量name、age等变量了\r\n\r\n\r\n    */\r\n    const renderBody = `with(this){\r\n        return ${code};\r\n    }`;\r\n    const renderFn = new Function(renderBody);\r\n\r\n    return renderFn;\r\n    \r\n}\r\n","import Watcher  from \"../observer/watcher\";\r\n/**\r\n * \r\n * @param {*} vm 实例\r\n * @param {*} element 根据用户传入的el生成的DOM元素\r\n */\r\nexport function mountComponent(vm, element) {\r\n    // 将element节点挂在vm上 可以在任意vm方法中读取\r\n    vm.$el = element;\r\n\r\n    /* \r\n        1. 执行render函数生成虚拟DOM\r\n        在源码里有一个vm._render方法，调用该方法其实就是调用vm.$options.render方法\r\n        该方法的返回值是一个虚拟DOM对象\r\n\r\n        2. 根据虚拟DOM产生真实DOM\r\n        在源码里有一个vm._update方法，调用该方法会将上一步生成的虚拟DOM转化为真实DOM\r\n\r\n        3. 将真实DOM插入到DOM节点中\r\n    */\r\n\r\n    // 只要一调用updateComponent 就会发生视图重新更新\r\n    const updateComponent = ()=>{\r\n        vm._update(vm._render());\r\n    }\r\n    // 第三个参数true表示是一个渲染watcher\r\n    new Watcher(vm,updateComponent,true);\r\n    \r\n}\r\n","// 策略对象集 最后会得到key为各生命周期函数名 value为生命周期函数的对象\r\nconst strats = {};\r\nconst LIFECYCLE = [\r\n\t\"beforeCreate\",\r\n\t\"created\",\r\n\t\"beforeMount\",\r\n\t\"mounted\",\r\n\t\"beforeUpdate\",\r\n\t\"updated\",\r\n\t\"beforeDestroy\",\r\n\t\"destroyed\",\r\n];\r\n\r\n/* \r\n  这里只是生命周期的策略，后续我们可以自定义任意策略：\r\n  strats.data = function(){};\r\n  strats.computed = function(){};\r\n  strats.watch = function(){};\r\n  ....\r\n*/\r\n\r\n\r\nfunction makeStrats(stratsList){\r\n\tstratsList.forEach(hook => {\r\n\t\tstrats[hook] = function(oldValue,newValue){\r\n\t\t\tif(newValue){\r\n\t\t\t\tif(oldValue){\r\n\t\t\t\t\treturn oldValue.concat(newValue);\r\n\t\t\t\t}else{\r\n\t\t\t\t\treturn [newValue];\r\n\t\t\t\t}\r\n\t\t\t}else{\r\n\t\t\t\treturn oldValue;\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n}\r\nmakeStrats(LIFECYCLE);\r\n\r\nexport default strats;","import  strats  from \"./strats.js\";\r\n\r\n/**\r\n * 将用户传入的options和Vue.options合并，并将合并的结果再次赋值给Vue.options\r\n * @param {*} oldOptions Vue.options全局配置\r\n * @param {*} newOptions 用户传入的options\r\n * \r\n * {} {created:fn1} => {created:[fn1]}\r\n * \r\n * {created :[fn1]}  {created:fn2} => {created:[fn1,fn2]}\r\n * \r\n */\r\n export function mergeOptions(oldOptions,newOptions){\r\n\tconst options = {};\r\n\r\n\t/* \r\n\t\t假设目前定义了a、b、c三种策略，属性d没有策略\r\n\r\n\t\t先以oldOptions也就是Vue.options上的key为基准，和当前的newOption进行合并\r\n\t\tVue.options = {a:[1],b:[2]}\r\n\t\tnewOptions = {a:3,c:4，d:5}\r\n\t\t这一轮过后由于以Vue.options上的key为基准，所以只会将属性a和b进行合并\r\n\t\t而newOptions中的属性c并不会合并，变为：\r\n\t\tVue.options = {a:[1,3],b:[2]}\r\n\t\t这一轮过后所有Vue.options中的key都会被处理，要不创建新数组包裹要不数组合并\r\n\t*/\r\n\tfor (const key in oldOptions) {\r\n\t\tmergeField(key);\r\n\t}\r\n\r\n\t/* \r\n\t\t再以newOptions上的key为基准，和当前的Vue.options中的key进行合并\r\n\t\tVue.options = {a:[1,3],b:[2]}\r\n\t\tnewOptions = {a:3,c:4}\r\n\t\t在上一轮已经合并过的a属性不会再被合并了，只合并c属性，d属性没有策略直接取newOptions的\r\n\t\t合并结果为：\r\n\t\tVue.options = {a:[1,3],b:[2]，c:[4],d:5}\r\n\t*/\r\n\tfor (const key in newOptions) {\r\n\t\tif(!oldOptions.hasOwnProperty(key)){\r\n\t\t\tmergeField(key);\r\n\t\t}\r\n\t}\r\n\r\n\t// 策略模式减少if - else 避免写很多if条件\r\n\tfunction mergeField(key){\r\n\t\t// 有策略优先走策略 说明我定义好了如何处理的策略\r\n\t\tif(strats[key]){\r\n\t\t\toptions[key] = strats[key](oldOptions[key], newOptions[key]);\r\n\t\t}else{\r\n\t\t\t// 如果没有策略那么以传入的newOptions中的key的值为主\r\n\t\t\toptions[key] = newOptions[key] || oldOptions[key];\r\n\t\t}\r\n\t}\r\n\treturn options;\r\n\r\n}\r\n\r\n","export function callHook(vm,hook){\r\n    let hookList=  vm.$options[hook];\r\n    if(Array.isArray(hookList)){\r\n        // 所有生命周期函数的this都是实例本身\r\n        hookList.forEach(hook=>hook.call(vm));\r\n    }\r\n}","import { initState } from \"./initState.js\";\r\nimport { compileToFunction } from \"../template-compiler/index.js\";\r\nimport { mountComponent } from \"../lifeCycle/mountComponent.js\";\r\nimport { mergeOptions } from \"../globalApi/mergeOptions.js\";\r\nimport { callHook } from \"../lifeCycle/callHook.js\";\r\n\r\nexport function initMixin(Vue) {\r\n  /* 在这里给Vue原型拓展两个方法 */\r\n  Vue.prototype._init = function (options) {\r\n    // 给生成的实例上挂载$options用于在其他地方获取用户传入的配置\r\n    let vm = this;\r\n\r\n    /**\r\n     * options是用户传入的配置项\r\n     * this.constructor.options是全局Vue上的静态options对象\r\n     *\r\n     * Vue.mixin的作用就是将全局的配置项合并成为一个对象，将相同key的值放入一个数组中\r\n     * Vue的实例在初始化的时候会再次将用户自己传入的配置项和之前全局的配置对象二次进行合并\r\n     * 这样做的好处是我们定义的全局Vue的filter、指令、组件component等最终都会挂载到每一个Vue的实例$options属性上\r\n     * 供Vue的实例this进行调用 这就是为什么全局的过滤器、组件在任意地方都可以访问调用的原因\r\n     * 这也是为什么全局的生命周期函数总是在实例之前调用的原因\r\n     */\r\n    vm.$options = mergeOptions(this.constructor.options, options);\r\n    // console.log(vm.$options);\r\n    \r\n    // data未初始化前调用beforeCreate生命周期函数\r\n    callHook(vm, \"beforeCreate\");\r\n\r\n    // 开始初始化options中的各个状态 data - props - methods...\r\n    initState(vm);\r\n\r\n    // data初始化完成之后调用created生命周期函数\r\n    callHook(vm, \"created\");\r\n\r\n    // 将模板进行编译 - 生成虚拟DOM - 挂载到真实DOM上\r\n    if (options.el) {\r\n      // 未挂载到DOM上前调用beforeMount生命周期函数\r\n\t\t\tcallHook(vm,'beforeMount');\r\n\r\n      vm.$mount(options.el);\r\n\r\n      // DOM挂载完成调用mounted生命周期函数\r\n\t\t\tcallHook(vm,'mounted');\r\n    }\r\n  };\r\n\r\n  Vue.prototype.$mount = function (elementSelector) {\r\n    let vm = this;\r\n    let options = vm.$options;\r\n    // 获取挂载的DOM元素节点\r\n    let element = document.querySelector(elementSelector);\r\n\r\n    /* \r\n\t\t\t编译模板优先级 render - template - el \r\n\t\t*/\r\n    if (!options.render) {\r\n      let templateString;\r\n\r\n      // 如果没有传递template属性但是有element\r\n      if (!options.template && element) {\r\n        templateString = element.outerHTML;\r\n      } else {\r\n        templateString = options.template;\r\n      }\r\n\r\n      // 确定template模板字符串，进行模板编译得到render函数\r\n      if (templateString) {\r\n        // 核心1：基于确定的模板字符串 模板编译 得到render函数\r\n        const render = compileToFunction(templateString);\r\n\r\n        // 核心2：将render函数挂载到options对象上\r\n        options.render = render;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * 组件的挂载\r\n     *\r\n     * 1. 执行上一步模板编译时生成的render函数，得到一个虚拟DOM对象\r\n     * 2. 将虚拟DOM对象更新到element 真实DOM元素上\r\n     * 3. render函数已经在上一步模板编译完成之后挂载到了options对象上，通过参数vm.$options获取\r\n     *\r\n     */\r\n    mountComponent(vm, element);\r\n  };\r\n}\r\n","/**\r\n *\r\n * @param {*} vm 实例\r\n * @param {*} tag 元素名称\r\n * @param {*} data data代表元素属性对象\r\n * @param  {...any} children 元素子节点\r\n * @returns\r\n */\r\nexport function createElementVNode(vm, tag, data, ...children) {\r\n  if (!data) {\r\n    data = {};\r\n  }\r\n  // 这个key就是虚拟DOM diff时的那个key，存在于属性data中\r\n  let key = data.key;\r\n\r\n  // 创建元素虚拟节点\r\n  return createVNode(vm, tag, key, data, children, null);\r\n}\r\n\r\n/**\r\n *\r\n * @param {*} vm 实例\r\n * @param {*} text 文本\r\n * @param {*} props 属性\r\n */\r\nexport function createTextVNode(vm, text) {\r\n  // 创建元素虚拟节点\r\n  return createVNode(vm, null, null, null, null, text);\r\n}\r\n\r\n/**\r\n *\r\n * @param {*} vm 实例对象\r\n * @param {*} tag 生成的元素节点名称\r\n * @param {*} key DOM diff时的ket\r\n * @param {*} props 生成的元素属性对象\r\n * @param {*} children 子元素组成的数组\r\n * @param {*} text 元素的文本\r\n */\r\nfunction createVNode(vm, tag, key, props, children, text) {\r\n  /* \r\n          问题：虚拟DOM和AST抽象树的区别\r\n  \r\n          AST是语法层面的转换，将html模板语法转化为JS对象，描述的是语法本身，不能自定义的去放置一些自定义的属性。HTML模板是什么转化出来就是什么，AST不仅可以描述html、还可以描述css、es6语法等。\r\n  \r\n          虚拟DOM是用JS语法描述DOM元素对象的，可以使用自定义的属性，比如事件、指令、插槽都可以自定义的去描述。\r\n      */\r\n  return {\r\n    vm,\r\n    tag,\r\n    key,\r\n    props,\r\n    children,\r\n    text,\r\n  };\r\n}\r\n","/**\r\n * patch方法是Vue中的更新视图的核心方法，Vue2.0、3.0都有\r\n *\r\n * patch方法可以用来将虚拟DOM转化为真实DOM\r\n * pathc方法也可以用来更新视图，DIff算法就走patch\r\n *\r\n *\r\n * @param {*} oldVNode 可能是初渲染的真实DOM，也可能是更新时传入的旧的虚拟DOM\r\n * @param {*} vNode 执行render函数生成的虚拟DOM对象\r\n */\r\nexport function patch(oldVNode, newVNode) {\r\n  // 如果oldVNode是一个真实的DOM元素 那么代表传递进来的是要挂载的DOM节点是初始化渲染\r\n  let isRealDomElement = oldVNode.nodeType;\r\n\r\n  if (isRealDomElement) {\r\n    // 初始化渲染流程\r\n\r\n    const oldElement = oldVNode;\r\n    const parentNode = oldElement.parentNode;\r\n    const newElement = createElement(newVNode);\r\n\r\n    // 基于最新的newVNode虚拟DOM生成的真实DOM节点先插入到旧节点的后面兄弟节点\r\n    parentNode.insertBefore(newElement, oldElement.nextSibling);\r\n    // 然后再将旧节点移除\r\n    parentNode.removeChild(oldElement);\r\n    // 最后返回新的真实DOM节点，挂载到vm.$el上，下次更新的时候直接去vm.$el上获取\r\n    return newElement;\r\n  } else {\r\n    /* \r\n        基于新旧DOM进行DIFF算法对比\r\n        1. 新节点和旧节点不是同一个节点，比如一个是div一个是p，那么直接删除旧节点替换新节点(不进行对比)\r\n        2. 两个节点是同一个节点（如何确定：节点的tag和key一样）那么比较两个节点的属性是否有差异（复用老节点 将差异的属性更新）\r\n        3. 节点比较完成之后就比较新旧节点的儿子节点\r\n    */\r\n    console.log(\"oldVNode\", oldVNode);\r\n    console.log(\"newVNode\", newVNode);\r\n    return patchVNode(oldVNode, newVNode);\r\n  }\r\n}\r\n\r\n/**\r\n * 检查新旧虚拟DOM节点是否相同 节点的tag和key一样\r\n * @param {*} oldVNode 旧的虚拟DOM节点\r\n * @param {*} newVNode 新的虚拟DOM节点\r\n */\r\nfunction isSameVNode(oldVNode, newVNode) {\r\n  return oldVNode.tag === newVNode.tag && oldVNode.key === newVNode.key;\r\n}\r\n\r\n/**\r\n * 对比新旧虚拟DOMnono并且返回更新后的新的DOM节点\r\n * @param {*} oldVNode 旧的虚拟DOM节点\r\n * @param {*} newVNode 新的虚拟DOM节点\r\n */\r\nfunction patchVNode(oldVNode, newVNode) {\r\n  /* \r\n      1：新节点和旧节点不是同一个节点\r\n      比如一个是div一个是p，那么直接删除旧节点替换新节点(不进行对比)\r\n   */\r\n  if (!isSameVNode(oldVNode, newVNode)) {\r\n    // 基于旧的虚拟DOM节点的el属性获取到真实DOM节点，然后获取其父节点调用replaceChild完成直接替换\r\n    const parentEl = oldVNode.el.parentNode;\r\n    // 将新节点的虚拟DOM转化为真实元素\r\n    const newEl = createElement(newVNode);\r\n    // 完成替换\r\n    parentEl.replaceChild(newVNode.el, oldVNode.el);\r\n    // 为了让方法保持一致的返回值 统一返回更新后的新节点的真实DOM\r\n    return newEl;\r\n  }\r\n\r\n  /* \r\n    代码走到这里说明新旧节点的tag和key是一定相等的，剩下的就应该对比三个地方：\r\n    1. 文本\r\n    2. 属性\r\n    3. 子节点\r\n  */\r\n\r\n  // 因为新旧节点相同，那么可以进行复用\r\n  let el = (newVNode.el = oldVNode.el);\r\n\r\n  /* \r\n      2：新节点和旧节点是同一个节点并且他们都是文本节点\r\n      也就是tag都是undefiend 符合节点相等的特点\r\n      此时我们要对比文本的内容然后只更旧节点的文本内容\r\n   */\r\n  if (!oldVNode.tag) {\r\n    // 如果新旧节点文本不一致 那么用新节点文本替换旧节点的文本部分\r\n    if (oldVNode.text !== newVNode.text) {\r\n      el.textContent = newVNode.text;\r\n    }\r\n  }\r\n\r\n  /* \r\n    3. 如果不是文本节点并且节点相同 那么应该对比节点的属性\r\n  */\r\n  patchProps(el, oldVNode.props, newVNode.props);\r\n\r\n  /* \r\n    4. 对比两个节点的儿子节点，对比策略是：\r\n    一个有子节点一个没有子节点\r\n    两个都有子节点\r\n  */\r\n  let oldChildren = oldVNode.children || [];\r\n  let newChildren = newVNode.children || [];\r\n\r\n  if (oldChildren.length > 0 && newChildren.length > 0) {\r\n    // 实现完整的DIff算法 需要对比两个节点的子节点\r\n    updateChildren(el, oldChildren, newChildren);\r\n  } else if (newChildren.length > 0 && oldChildren.length == 0) {\r\n    // 新节点有子节点 老节点没有子节点 那么直接将新节点的子节点挂载到le上\r\n    mountChildren(el, newChildren);\r\n  } else if (oldChildren.length > 0 && newChildren.length == 0) {\r\n    // 旧节点有子节点 新节点没有子节点 那么直接将旧节点的所有子节点从el上移除即可\r\n    unMountChildren(el, oldChildren);\r\n  }\r\n\r\n  // 返回更新后的真实DOM节点\r\n  return el;\r\n}\r\n\r\n/**\r\n * 将虚拟DOM vNode转化为 真实DOM节点\r\n * JS对象 ==> HTML Element\r\n */\r\nexport function createElement(vNode) {\r\n  let { tag, props, children, text } = vNode;\r\n\r\n  // 创建真实元素节点\r\n  if (typeof tag === \"string\") {\r\n    // 虚拟DOM和真实DOM连接起来,后续如果修改属性了，可以直接找到虚拟节点对应的真实节点修改\r\n    vNode.el = document.createElement(tag);\r\n\r\n    // 给节点属性赋值\r\n    patchProps(vNode.el, {}, props);\r\n\r\n    // 给节点添加子节点\r\n    children.forEach((childvNode) => {\r\n      vNode.el.appendChild(createElement(childvNode));\r\n    });\r\n  } else {\r\n    // 创建真实文本节点\r\n    vNode.el = document.createTextNode(text);\r\n  }\r\n\r\n  return vNode.el;\r\n}\r\n\r\n/**\r\n * 更新节点的属性，并且对相同属性名的更新进行复用，比如color:red和color:blue只更新属性值，而不是先将\r\n * 属性color删除，然后再新建属性color赋值给blue\r\n *\r\n * @param {Object} element 当前属性要挂载的元素节点\r\n * @param {Object} oldProps 旧的虚拟DOM节点的props对象 初始化时为空{}\r\n * @param {Object} newProps 新的虚拟DOM节点的props对象\r\n *\r\n * 一个vNode的props中的属性来源两个部分：props:{ id:'app',style:{ color:red}}\r\n * 1. 节点的style属性，多和样式有关\r\n * 2. 节点的attribute属性，比如id、key、disbaled等\r\n *\r\n * 所以属性对比更新规则为：\r\n * 1. 如果某个属性旧节点中有，新节点中却没有了，此时需要删除这个旧的属性\r\n * 2. 删除之后用新节点的属性值覆盖旧节点的属性值即可\r\n *\r\n *\r\n */\r\nexport function patchProps(element, oldProps, newProps) {\r\n  let oldStyle = oldProps?.style || {};\r\n  let newStyle = newProps?.style || {};\r\n\r\n  // 旧的style中有的属性 新的sytle没有 则从DOM节点上的style表中将属性删除\r\n  for (const key in oldStyle) {\r\n    if (!newStyle[key]) {\r\n      element.style[key] = \"\";\r\n    }\r\n  }\r\n\r\n  // 旧的props中有的属性 新的props没有 则从DOM节点上将属性移除\r\n  for (const key in oldProps) {\r\n    if (!newProps[key]) {\r\n      element.removeAttribute(key);\r\n    }\r\n  }\r\n\r\n  // 经过上诉删除之后剩下的都是新属性或者相同key的属性，此时直接用新的替换旧的即可\r\n  for (const key in newProps) {\r\n    if (key === \"style\") {\r\n      for (const key in newStyle) {\r\n        element.style[key] = newStyle[key];\r\n      }\r\n    } else {\r\n      element.setAttribute(key, newProps[key]);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * 将newChildren的所有节点挂载到el元素上\r\n */\r\nfunction mountChildren(el, newChildren) {\r\n  for (const childVNode of newChildren) {\r\n    // 将子节点的虚拟节点变为真实节点\r\n    let childEl = createElement(childVNode);\r\n    // 将新节点挂载到el元素上\r\n    el.appendChild(childEl);\r\n  }\r\n}\r\n\r\n/**\r\n * 将oldChildren的所有节点从el元素上移除\r\n */\r\nfunction unMountChildren(el, oldChildren) {\r\n  for (const childVNode of oldChildren) {\r\n    //  旧的虚拟DOM节点上都有el属性 代表其真实DOM节点\r\n    el.removeChild(childVNode.el);\r\n  }\r\n}\r\n\r\n/**\r\n * 虚拟DOM DIFF算法核心方法\r\n *\r\n * 特殊情况：四指针法\r\n * oldChildren：A B C D\r\n * newChildren: A B C\r\n *\r\n * oldChildren和newChildren一开始的头尾都各有一个left和right指针，一开始两个left指针指向的节点进行对比，如果节点对比相同那么left指针前进+1，直到有任意一个left指针的值大于right指针了，那么终止循环对比。此时要不是从尾部将新的节点插入，或者从尾部将多余的节点删除。\r\n *\r\n */\r\nfunction updateChildren(el, oldChildren, newChildren) {\r\n  // 四个指针\r\n  let oldStartIndex = 0;\r\n  let oldEndIndex = oldChildren.length - 1;\r\n  let newStartIndex = 0;\r\n  let newEndIndex = newChildren.length - 1;\r\n\r\n  // 四个指针初始指向的节点\r\n  let oldStartVNode = oldChildren[0];\r\n  let oldEndVNode = oldChildren[oldEndIndex];\r\n  let newStartVNode = newChildren[0];\r\n  let newEndVNode = newChildren[newEndIndex];\r\n\r\n  /* \r\n    对比的条件：如果有任意一方的头指针大于尾指针 那么对比结束停止循环\r\n  */\r\n  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {\r\n    /* \r\n      1. 如果两个初始头指针指向的节点相同，则从头开始比\r\n        abc => abcde  abcde=>abc\r\n    */\r\n    if (isSameVNode(oldStartVNode, newStartVNode)) {\r\n      // 递归比较子节点\r\n      patchVNode(oldStartVNode, newStartVNode);\r\n      // 双指针向前进并且更新指向的节点\r\n      oldStartIndex++;\r\n      newStartIndex++;\r\n      oldStartVNode = oldChildren[oldStartIndex];\r\n      newStartVNode = newChildren[newStartIndex];\r\n      // 加continue的原因就为了控制头尾指针都一直 进入到两个if语句中造成指针的混乱 比如abc和abc\r\n      continue;\r\n    }\r\n    /* \r\n      2. 如果两个初始尾指针指向的节点相同，则从尾开始比\r\n        abc => dabc  dabc => abc \r\n    */\r\n    if (isSameVNode(oldEndVNode, newEndVNode)) {\r\n      // 递归比较子节点\r\n      patchVNode(oldEndVNode, newEndVNode);\r\n      // 双指针向后退更新指向的节点\r\n      oldEndIndex--;\r\n      newEndIndex--;\r\n      oldEndVNode = oldChildren[oldEndIndex];\r\n      newEndVNode = newChildren[newEndIndex];\r\n      continue;\r\n    }\r\n\r\n    /* \r\n      3. 如果旧的尾巴节点和新的头节点相同，那么进行交叉对比\r\n      abcd => dabc ：d和d对比相同，此时将旧的d移动到旧的a前面，复用了abc三个节点的相对位置\r\n    */\r\n    if (isSameVNode(oldEndVNode, newStartVNode)) {\r\n      // 递归比较子节点\r\n      patchVNode(oldEndVNode, newStartVNode);\r\n      // 先将旧的oldEndVNode移动到oldStartVNode前面去\r\n      el.insertBefore(oldEndVNode.el, oldStartVNode.el);\r\n      //  旧的尾指针--，新的头指针++\r\n      oldEndIndex--;\r\n      newStartIndex++;\r\n      oldEndVNode = oldChildren[oldEndIndex];\r\n      newStartVNode = newChildren[newStartIndex];\r\n      continue;\r\n    }\r\n\r\n    /* \r\n      4. 如果旧的头节点和新的尾节点相同，那么进行交叉对比\r\n      abcd => bcda ：a和a对比相同，此时将旧的a移动到旧的d后面，复用了bcd三个节点的相对位置\r\n\r\n      5. 此种更新也适用于排序元素与倒序元素更新的情况，此时也是交叉对比，比如：\r\n      abcd => dcba 头结点和尾结点相同，那么依次将旧的a、b、c移动到d的下一个子节点前面，复用了节点d，最终效果是dcba\r\n    */\r\n      if (isSameVNode(oldStartVNode, newEndVNode)) {\r\n        // 递归比较子节点\r\n        patchVNode(oldStartVNode, newEndVNode);\r\n        // 先将旧的oldStartVNode移动到oldEndVNode的下一个节点的前面\r\n        el.insertBefore(oldStartVNode.el, oldEndVNode.el.nextSibling);\r\n        //  旧的头指针++，新的尾指针--\r\n        oldStartIndex++;\r\n        newEndIndex--;\r\n        oldStartVNode = oldChildren[oldStartIndex];\r\n        newEndVNode = newChildren[newEndIndex];\r\n        continue;\r\n      }\r\n  }\r\n\r\n  /* \r\n    特殊情况1：新的子节点多余旧的子节点，此时需要尽可能复用重复的，只将多出来的差异部分从头部或者尾部插入\r\n    这种情况下一定当旧的头指针大于尾指针时退出循环，此时新的头指针一定小于尾指针，举例：\r\n    old：a b c   =>   new：a b c d e 新的头指针指向d，尾指针指向e，将这两个元素取出来从尾部插入\r\n    old：a b c   =>   new：d e a b c  新的头指针指向d，尾指针指向e，将这两个元素取出来以a为参数物依次插入到a的前面\r\n   \r\n    那么如何用代码判断是从头部插入还是尾部插入呢？\r\n    判断newEndIndex的下一个节点指向的是null还是节点；如果是null代表是尾部插入的情况；如果是节点代表是头部插入的情况。\r\n\r\n    如果是头部插入以那个节点为参照物呢？\r\n    如果是头部插入，那么以newEndIndex的下一个节点也就是上面的a节点为参照物anchor，然后将多余的节点依次插入到a的前面\r\n\r\n    API:parentNode.insertBefore(newNode, referenceNode);\r\n    当referenceNode为节点时，代表将新节点插入到referenceNode节点的前面，它们同属parentNode的子节点\r\n    当referenceNode为null时，代表将新节点直接插入到父节点的尾部\r\n\r\n    所以我们只需要以anchor作为第二个参数，当anchor为null那就是尾部插入；否则就是头部依次插入。\r\n\r\n    其实以上情况就是模拟了我们最常见的操作数组的尾部push和头部unshift的特殊情况。\r\n\r\n  */\r\n  if (newStartIndex <= newEndIndex) {\r\n    for (let i = newStartIndex; i <= newEndIndex; i++) {\r\n      const childVNode = newChildren[i];\r\n      const childEl = createElement(childVNode);\r\n\r\n      // 找到参照物节点\r\n      let anchor = newChildren[newEndIndex + 1]\r\n        ? newChildren[newEndIndex + 1].el\r\n        : null;\r\n      el.insertBefore(childEl, anchor);\r\n    }\r\n  }\r\n\r\n  /* \r\n    特殊情况2：新子节点比旧子节点少，需要尽可能复用重复的，只将差异部分从尾部移除或者头部移除\r\n    这种情况下一定是新的指针先遍历完，那么一定是新的头指针大于尾指针时退出循环，此时旧的头指针一定小于尾指针，举例：\r\n    old：a b c d e  =>  new：a b c 旧的头指针此时指向d，尾指针指向e，将这两个节点从原来的节点上移除即可\r\n    old：d e a b c  =>  new：a b c 旧的头指针此时指向d，尾指针指向e，将这两个节点从原来的节点上移除即可\r\n\r\n    和新增不同，不管是尾部移除还是头部移除，直接移除即可，不用区分头部还是尾部的情况。\r\n    其实这就模拟了我们最常见的操作数组的头部移除shift和尾部移除pop的特殊情况。\r\n  */\r\n  if (oldStartIndex <= oldEndIndex) {\r\n    for (let i = oldStartIndex; i <= oldEndIndex; i++) {\r\n      const childVNode = oldChildren[i];\r\n      const childEl = childVNode.el;\r\n      el.removeChild(childEl);\r\n    }\r\n  }\r\n}\r\n","import { createElementVNode, createTextVNode } from \"../vdom/createNode.js\";\r\nimport { patch } from \"../vdom/patch.js\";\r\n\r\n/**\r\n * Vue核心流程\r\n * 1. 基于vm.data初始化，创建响应式数据\r\n * 2. 基于模板编译，生成AST抽象语法树\r\n * 3. 基于ast语法树，通过代码生成原理生成render函数\r\n * 4. 执行render函数生成虚拟DOM，在执行的过程中会使用到响应式数据\r\n * 5. 根据生成虚拟DOM创建出真实DOM节点\r\n *\r\n * 之后每次数据更新，无需再进行模板编译到生成render函数的这个耗时过程，因为这个过程涉及到了正则匹配，而是直接执行render函数生成新的虚拟DOM，对比新旧虚拟DOM然后更新视图\r\n */\r\n\r\nexport function initLifeCycle(Vue) {\r\n  /**\r\n   *  1. _render方法的返回值：虚拟DOM\r\n   *\r\n   *  2.  _render方法运行时的this\r\n   *  在通过模板AST语法树生成的render函数中,由于使用with绑定了this为目标作用域，而render函数体中的name、age等变量又需要去vm上取值，所以这里使用call绑定vm为render函数运行时的this对象。\r\n   *\r\n   *  3. 执行render函数的时候，里面的_c、_s、_v是没有定义的，所以需要定义这三个函数\r\n   *\r\n   *  4. 执行render函数的时候，会去vm上取属性的值，就会触发getter和setter\r\n   *   触发之后就可以将视图和属性绑定在一起\r\n   */\r\n  Vue.prototype._render = function () {\r\n    const vm = this;\r\n    let vNode= vm.$options.render.call(vm);\r\n    // console.log(\"_render函数执行，生成的虚拟DOM节点为\", vNode);\r\n    return vNode;\r\n  };\r\n\r\n  /**\r\n   * _update方法的核心就是将上一步执行render函数生成的虚拟DOM vNode转化为真实DOM\r\n   * 它的核心就是调用一个核心方法patch，通过递归调用createElement方法来生成\r\n   * 真实的元素节点和文本节点\r\n   */\r\n  Vue.prototype._update = function (vNode) {\r\n    /* \r\n      首次渲染，vm.$el的值是基于用户传入的el获取到的DOM元素对象\r\n      用于将生成的真实DOM替换此DOM元素，同时会在patch完成之后给vm.$el赋值给新的真实DOM\r\n\r\n      之后更新，vm.$el的值就变成了上一次生成的真实DOM\r\n    */\r\n    const vm = this;\r\n    const element = vm.$el;\r\n\r\n    /**\r\n     * 1. 获取基于vNode虚拟DOM生成的真实DOM节点\r\n     * 2. 将真实DOM节点替换到旧的element元素节点上\r\n     * 3. 将真实DOM节点赋值给实例的$el属性，方便在下一次更新的时候传递oldVNode的时候，参数就是上一次生成的$el属性\r\n     *\r\n     */\r\n\r\n    let truthDom = patch(element, vNode);\r\n    vm.$el = truthDom;\r\n    // console.log(\"_update函数执行，执行patch函数渲染虚拟DOM，生成真实DOM\",truthDom);\r\n  };\r\n\r\n  /* 生成虚拟DOM元素节点 */\r\n  Vue.prototype._c = function () {\r\n    return createElementVNode(this, ...arguments);\r\n  };\r\n\r\n  /* 生成虚拟DOM文本节点 */\r\n  Vue.prototype._v = function () {\r\n    return createTextVNode(this, ...arguments);\r\n  };\r\n\r\n  /* 将参数进行字符串转义 */\r\n  Vue.prototype._s = function (value) {\r\n    if (!(value instanceof Object)) return value;\r\n    return JSON.stringify(value);\r\n  };\r\n}\r\n\r\n\r\n","import {nextTick} from '../observer/nextTick.js';\r\nimport {mergeOptions} from \"./mergeOptions.js\";\r\nimport Watcher from \"../observer/watcher.js\"\r\n\r\nexport function initGlobalApi(Vue) {\r\n    // 原型挂载核心API\r\n\tVue.prototype.$nextTick = nextTick;\r\n\r\n    /* Vue类的静态全局配置对象 */\r\n\tVue.options = {};\r\n\r\n    /**\r\n\t * 调用 一次mixin，就把选项中的created取出来挂到Vue.options的created数组\r\n\t * \r\n\t * 将全局的Vue.options对象和用户传入的mixinOptions进行合并\r\n\t * 合并完成之后将结果赋值给全局Vue.options对象对应的key的数组上\r\n\t * @param {Object} mixinOptions\r\n\t */\r\n    Vue.mixin = function(mixinOptions){\r\n        // this就是Vue构造函数\r\n        this.options = mergeOptions(this.options,mixinOptions);\r\n        // 链式调用返回Vue构造函数\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * 监控某个属性的变化，然后调用回调函数\r\n     * @param {*} exprOrFn 有可能是函数()=>{vm.xxx} 也有可能是字符串vm实例上的属性名'xxx'\r\n     * @param {*} callback 回调函数\r\n     */\r\n    Vue.prototype.$watch = function(exprOrFn,callback,options = {}){\r\n        console.log(`创建watch属性，要监控的属性名为${exprOrFn},回调函数为${callback}`);\r\n\r\n        /* \r\n            调用$watch的核心就是调用new Watcher\r\n            1. this就是vm实例\r\n            2. exprOrFn就是需要观察的vm实例上的属性名字符串或者函数，我们会在Watcher中将字符串变为函数\r\n            3. 配置项{user:true}告诉Watcher这是一个用户自定义的watcher\r\n            4. callback 观察的属性发生变化的时候执行的回调函数\r\n        */\r\n        new Watcher(this,exprOrFn,{user:true},callback);\r\n    }\r\n}","/* 打包入口文件 */\r\nimport { initMixin } from \"./init/init.js\";\r\nimport { initLifeCycle } from \"./lifeCycle/initLifeCycle.js\";\r\nimport { initGlobalApi } from \"./globalApi/index.js\";\r\n\r\n// Vue构造函数\r\nfunction Vue(options) {\r\n  this._init(options);\r\n}\r\n\r\n// 给Vue类拓展初始化options的方法\r\ninitMixin(Vue);\r\n\r\n// 模板编译 组件挂载 vm._update vm._render方法 patch方法\r\ninitLifeCycle(Vue);\r\n\r\n// 全局API Vue.mixin nexttick和$watch\r\ninitGlobalApi(Vue);\r\n\r\n/* 测试DOM DIff的代码 */\r\nimport { compileToFunction } from \"./template-compiler/index.js\";\r\nimport { createElement, patch } from \"./vdom/patch.js\";\r\n\r\nlet render1 = compileToFunction(`<ul id=\"1\" style=\"color:red;font-size:16px\">\r\n\t<li key=\"a\">a</li>\r\n\t<li key=\"b\">b</li>\r\n\t<li key=\"c\">c</li>\r\n\t<li key=\"d\">d</li>\r\n</ul>`);\r\nlet vm1 = new Vue({ data: { name: \"你好啊，李银河！\" } });\r\nlet oldVNode = render1.call(vm1);\r\nlet oldEl = createElement(oldVNode);\r\ndocument.body.appendChild(oldEl);\r\n\r\nlet render2 =\r\n  compileToFunction(`<ul id=\"2\" style=\"color:yellow;background:pink\">\r\n\t<li key=\"d\">d</li>\r\n\t<li key=\"c\">c</li>\r\n\t<li key=\"b\">b</li>\r\n\t<li key=\"a\">a</li>\r\n</ul>`);\r\nlet vm2 = new Vue({ data: { name: \"你好啊，李银河！\" } });\r\nlet newVNode = render2.call(vm2);\r\n// let newEl = createElement(newVNode);\r\n\r\n// 新DOM替换旧DOM\r\n// let parentEl = oldEl.parentNode;\r\n\r\nsetTimeout(() => {\r\n  /*  \r\n\t直接用新节点替换老节点\r\n \tparentEl.insertBefore(newEl, oldEl);\r\n  \tparentEl.removeChild(oldEl); \r\n */\r\n\r\n  patch(oldVNode, newVNode);\r\n}, 1000);\r\n\r\nexport default Vue;\r\n"],"names":["id","Dep","subs","target","addDep","watcher","push","forEach","update","stack","pushTarget","popTarget","pop","length","observe","data","__ob__","Observer","dep","Object","defineProperty","value","enumrable","configurable","Array","isArray","newArrayProto","createNewArrayProto","__proto__","observeArray","walk","keys","key","defineReactive","item","dependArray","depend","childOb","get","set","newValue","notify","oldArrayProto","prototype","create","methods","method","args","result","call","inserted","slice","proxy","vm","initData","$options","_data","timerFunction","getTimerFunction","Promise","resolve","then","flashCallBacks","MutationObserver","mutationOb","textNode","document","createTextNode","characterData","textContent","setImmediate","setTimeout","callBacks","waiting","nextTick","callback","console","log","cbs","cb","Watcher","exprOrFn","options","renderWatcher","getter","deps","depsId","Set","lazy","dirty","user","depId","has","add","addSub","queneWatcher","oldValue","i","quene","pending","flushSchedulerQuene","flushWatcherQuene","run","initComputed","computed","watchers","_computedWatchers","hasOwnProperty","userDefine","defineComputed","setter","createComputedGetter","evaluate","initWatch","watchOptions","watch","handler","createWatcher","$watch","initState","props","initProps","ncname","qnameCapture","startTagOpen","RegExp","endTag","startTagClose","attribute","defaultTagReg","ELEMENT_TYPE","TEXT_TYPE","parseHTML","htmlStr","root","tagStack","currentParent","onParseStartTag","tagName","attrs","astNode","createASTElement","parent","children","onParseText","text","replace","nodeType","onParseEndTag","topNodeElement","tag","error","advance","startIndex","parseStartTag","startTagOpenMatchResult","match","parseResult","attrMatchResult","startTagCloseMatchResult","name","textEndIndex","indexOf","startTagParseResult","endTagParseResult","generatorProps","propsStr","attr","styleObj","split","k","v","trim","JSON","stringify","generatorChildren","map","generatorChild","join","codeGenerator","content","test","tokens","defaultTagMatchRes","lastIndex","exec","matchStartIndex","index","token","astTree","childrenCode","code","compileToFunction","templateString","renderBody","renderFn","Function","mountComponent","element","$el","updateComponent","_update","_render","strats","LIFECYCLE","makeStrats","stratsList","hook","concat","mergeOptions","oldOptions","newOptions","mergeField","callHook","hookList","initMixin","Vue","_init","constructor","el","$mount","elementSelector","querySelector","render","template","outerHTML","createElementVNode","createVNode","createTextVNode","patch","oldVNode","newVNode","isRealDomElement","oldElement","parentNode","newElement","createElement","insertBefore","nextSibling","removeChild","patchVNode","isSameVNode","parentEl","newEl","replaceChild","patchProps","oldChildren","newChildren","updateChildren","mountChildren","unMountChildren","vNode","childvNode","appendChild","oldProps","newProps","oldStyle","style","newStyle","removeAttribute","setAttribute","childVNode","childEl","oldStartIndex","oldEndIndex","newStartIndex","newEndIndex","oldStartVNode","oldEndVNode","newStartVNode","newEndVNode","anchor","initLifeCycle","truthDom","_c","arguments","_v","_s","initGlobalApi","$nextTick","mixin","mixinOptions","render1","vm1","oldEl","body","render2","vm2"],"mappings":"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"}